0X01 什么是泛型?
1. 泛型就是编写模板代码来适应任意类型.
2. 泛型的好处是使用时不比对类型做强制转换,它通过编译器对类型进行检查.
3. 使用泛型时,把泛型参数<T>替换为需要的class类型.
4. 可以省略编译器能自动推断出的类型.
5. 不指定泛型类型时,编译器会给出警告,且只能将<T>视为Object类型.
6. 可以在接口中定义泛型类型,实现此接口的类必须实现正确的泛型类型.
0X02 编写泛型
1. 编写泛型时,需要定义泛型类型<T>.
2. 静态方法不能引用泛型类型<T>,必须定义其他类型(例如:<K>)来实现静态泛型方法.
3. 泛型可以同时定义多种类型,例如:Map<K, V>.
0X03 擦拭法
1. Java的泛型是采用擦拭法实现的.
2. 擦拭法决定了泛型<T>:
    + 不能是基础类型,例如: int.
    + 不能获取带泛型类型的class,例如: Pair<String>.class.
    + 不能判断带泛型类型的类型,例如: x instanceof Pair<String>.
    + 不能实例化T类型,例如: New T().
3. 泛型方法要防止重复定义方法,例如: public boolean equals(T obj)
4. 子类可以获取父类的泛型类型<T>.
0X04 extends通配符
1. 使用类似<? extends Number>通配符作为方法参数时表示:
    + 方法内部可以调用获取Number引用的方法.
    + 方法内部无法调用传入Number引用的方法(null除外).
    + 一句话总结: 使用extends通配符表示可以读,不能写.
2. 使用类似<T extends Number>定义泛型时表示:
    + 泛型限定为Number以及Number的子类.
0X05 super通配符
1. 使用类似<? super Integer>通配符作为方法参数时表示:
    + 方法内部可以调用传入Integer引用的方法,例如: obj.setFirst(Integer n).
    + 方法内部无法调用获取Integer引用的方法(Object除外),例如: Integer n = obj.getFirst().
    + 一句话总结: 使用super通配符表示只能写不能读.
2. 使用extends和super通配符要遵循PECS原则:
    + 如果需要返回T,它是生产者,要使用extends通配符;如果需要写入T,它是消费者,要使用super通配符.
3. 无限定通配符<?>很少使用,可以用<T>替换,同时它是所有<T>类型的超类.
