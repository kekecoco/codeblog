### 面试日常记录   
#### 0X01 58同城
1. 给一张表,要求按照score进行倒序排列给出具体名次并解决并列排名的问题.  
```
CREATE TABLE `players` (
  `uid` int(2) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL,
  `score` int(2) NOT NULL,
  PRIMARY KEY (`uid`),
  UNIQUE KEY `name` (`name`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8mb4;

INSERT INTO `players` (`uid`, `name`, `score`) VALUES
(1, 'Samual', 25),
(2, 'Vino', 20),
(3, 'John', 20),
(4, 'Andy', 22),
(5, 'Brian', 21),
(6, 'Dew', 24),
(7, 'Kris', 25),
(8, 'William', 26),
(9, 'George', 23),
(10, 'Peter', 19),
(11, 'Tom', 20),
(12, 'Andre', 20);
```
```
SQL语句:
SELECT uid, name, score,
CASE
WHEN @prevRank = score THEN @currentRank
WHEN @prevRank := socre THEN @currentRank := @currentRank + 1
END AS rank
FROM players p,
(SELECT @currentRank := 0, @prevRank := NULL) r
ORDER BY SOCRE DESC;
注: := 为赋值符号; =为比较符号.
```
2. MySQL的int数据类型数据范围.    
```
Type	    Storage (Bytes)	  Minimum Value Signed	Minimum Value Unsigned	Maximum Value Signed	Maximum Value Unsigned     
TINYINT	    1	              -128	                0	                    127	                    255    
SMALLINT	2	              -32768	            0	                    32767	                65535    
MEDIUMINT	3	              -8388608	            0	                    8388607	                16777215   
INT      	4	              -2147483648	        0	                    2147483647	            4294967295   
BIGINT	    8	              -2^63	                0	                    2^63-1	                2^64-1   
注: MySQL还支持在该类型后面的括号内指定整数值的显示宽度(最大支持255).该可选显示宽度规定用于显示宽度小于指定的列宽度的值时从左侧填满宽度.
显示宽度并不限制可以在列内保存的值的范围,也不限制超过列的指定宽度的值的显示.
```
3. 取出文件的前xx行数据.
head -n 100 demo.txt
4. 移位运算.
$a << $b	Shift left（左移）	将 $a 中的位向左移动 $b 次（每一次移动都表示“乘以 2”）。
$a >> $b	Shift right（右移）	将 $a 中的位向右移动 $b 次（每一次移动都表示“除以 2”）。
5. PHP的session存储配置.
自定义session存储: 
session.save_handler = redis
session.save_path = "tcp://127.0.0.1:6379"
注: 
1. 自定义会话管理器是有各扩展实现的.  
2. 需要使用session_set_save_handle()函数或SessionHandlerInterface类或者通过继承SessionHandler类来扩展内置的管理器,
从而达到自定义会话保存机制的目的.  
6. 字符串数组是否有版本限制.
PHP 5.5 增加了直接在字符串原型中用[]或{}访问字符的支持。     
#### 0X02 阿里-神马搜索(电话)  
1. 序列化与反序列化对单例模式的破坏.   
序列化和反序列化时, 单例模式返回的对象会受破坏.解决办法对__sleep()和__wakeup()魔术方法做私有化限制.
2. PHP多态实现的特点.   
多态是指在面向对象中能够根据使用类的上下文来重新定义或改变类的性质或行为.
抽象类和方法:  
* 抽象类: 
  一个类中只要有一个抽象方法,则这个类就是抽象类.   
  抽象类不能直接实例化必须先实现抽象方法.
* 接口:  
  用interface声明的类.接口中所有的方法都要求是抽象方法.
  接口中所有的方法都默认是public也只能是public.
  接口中的所有方法没有方法体.
  接口没有构造函数.
* 区别:  
  抽象用于不同的事物,接口用于事物的行为.    
#### 0X03 贝壳找房
1. MongoDB索引与MySQL索引的区别.
* MongoDB支持的索引类型: 单字段索引, 复合索引, 多key索引, 文本索引等.
* MongoDB使用B-tree作为索引数据结构.
2. MySQL查询执行流程.
* SQL ==> 查询缓存 ==> 语法解析器 ==> 解析树 ==> 预处理器 ==> 解析树 ==> 查询优化器 ==> 查询执行引擎 ==> 返回结果
* 语法解析器: 验证SQL的语法是否合法且正确.
* 预处理器: 根据MySQL的规则进一步检查解析树是否正确.例如: 表是否存在, 数据列是否存在.
3. PHP后期静态绑定.
* 含义: static:: 不在被解析为定义当前方法所在的类,而是实际运算时计算的.
* 转发调用: 在静态调用时未指定类名的调用属于转发调用.具体指: static::, self::, parent::, forward_static_call().
* 非转发调用: 明确指定类名的静态调用和非静态调用.具体指: foo::bar(), $foo->bar().
* 非转发调用之前的类名已明确指定具体的类,所以调用的方法确定一定是属于这个类的,不需要转到别的类.转发调用就是由于前期的静态绑定导致在后面进行方法调用时可能转发到其他的类.
* 后期静态绑定的原理: 存储了一个"非转发调用"中的类名.意思是当调用一个转发调用的静态调用时,实际调用的类名是上一个非转发调用的类.
4. PHP垃圾回收机制.
* 垃圾的产生: 变量的内部成员引用了变量自身, 这种变量的循环引用最终会变为垃圾.
```
$a = [1];
$a[] = &$a;
```
* 垃圾回收准则:  
    1. 如果一个变量value的refcount减少到0,那么此value可以被释放掉,不属于垃圾.
    2. 如果一个变量value的refcount减少之后大于0,那么此zval还不能被释放掉,此zval可能成为一个垃圾.
针对第一种情况GC不会进行处理,只有第二种情况GC才会将变量收集起来.另外变量是否加入垃圾检查buffer不是根据zval的类型判断的,而是通过zval.u1.type_flag记录的,只有包含IS_TYPE_COLLECTABLE
的变量才会被GC收集.
目前垃圾只会出现在array和object两种类型中.垃圾回收只会处理这两种数据类型产生的垃圾.
* 回收过程:  
    1. 如果变量的refcount减少后还是大于0,PHP会将其放入buffer缓冲区中,等这个buffer满了之后(10000个值)再统一进行处理.
    2. 具体过程:  
        - 从buffer链表的roots开始遍历,把当前value标记为灰色,然后对当前value的成员进行深度遍历,把成员value的refcount减1,并且标记为灰色.
        - 重复遍历buffer链表,检查当前value引用是否为0,为0表示确实是垃圾,把它标为白色, 如果不为0则排除了引用全部来自自身的情况,需要再次深度遍历将refcount加1还原回去,同时标记为黑色.
        - 再次遍历buffer链表,将非白色的节点从链表中删除,最终剩下的即为垃圾,最后将这些垃圾进行清除.   
#### 0X04 快手
1. OSI七层模型: 
 * 应用层
 * 表示层
 * 会话层
 * 运输层
 * 网络层
 * 数据链路层
 * 物理层     
#### 0X05 新浪微博
1. MySQL binlog日志的三种格式:
 * statement: 每一条会修改数据的SQL都会记录在binlog中.
 * Row: 不记录SQL语句上下文的相关信息,仅保存哪些记录被修改.(仅需要记录一条数据被修改成了什么)
 * mixed level: 是以上两种格式混合使用, 一般的语句修改使用statement格式保存binlog,如一些函数的使用, statement无法完成主从复制的操作.
 需要使用row格式保存binlog.
2. register_shutdown_function():
 * 注册一个会在PHP终止时执行的函数.
 * 注册一个callback, 它会在脚本执行完成之或者exit()后被调用.
 * 可以多次调用register_shutdown_function(),这些被注册的回调会按照他们注册的顺序被依次调用.如果你在注册的方法内部调用exit(),那么所有的
 处理会被终止,并且其他注册的终止回调也不会再被执行.
 * 如果进程被信号SIGTERM或SIGKILL杀死,那么终止函数将不会被调用.尽管你无法中断SIGKILL,但你可以通过pcntl_signal()来捕获SIGTERM,通过
 在其中调用exit()来进行一个正常的终止.
 * 如果脚本执行时间超时被终止,该函数还是可以继续执行.
3. mysqli无法设置超时时间:
 * mysqli仅支持连接超时时间,无法设置查询超时时间.
 * mysqli底层超时时间设置单位为秒,最少配置1秒.
 * mysqli底层的read会重试两次,所以实际时间是3秒.
 * MYSQL_OPT_READ_TIMEOUT = 11; MYSQL_OPT_WRITE_TIMEOUT = 12.    
#### 0X06 斗鱼直播
1. MySQL GROUP BY可以对多列进行分组. 
#### 0X07 百度  
1. Linux sort排序.
```
> -u: 在输出行中去除重复行.
> -r: 按照倒序排列.
> -o: 将输出结果写入文件.
> -n: 以数值来排序.
> -t: 设置间隔符.
> -k: 指定排序的列数.(从1开始)
```
2020年面试
#### 0X01 跟谁学 PHP数据中台
1. Redis中RDB的实现:
  * RDB持久化既可以手动执行,也可以根据服务器配置选项定期执行,该功能可以将某个时间点上的数据库状态保存到磁盘中.
  * RDB持久化所生成的是一个经过压缩的二进制文件,通过该文件可以还原生成RDB文件时的数据库状态.
  * 有两个命令可以生成RDB文件,一个是SAVE,一个是BGSAVE.
  * RDB文件的载入是在Redis服务器启动时自动执行的.
    * 如果数据库启动了AOF持久化,服务器会优先使用AOF文件来还原数据库状态.
    * 只有在AOF持久化关闭的情况下,才会使用RDB文件来还原数据库状态.
  * Save命令执行时,服务器的状态:
    * Redis服务器会被阻塞,只有执行完Save命令,才会重新开始接受请求.
  * BGSAVE命令执行时,服务器的状态:
    * Redis服务器仍然可以接受处理客户端的命令请求.
    * 客户端发送的SAVE命令会被服务器拒绝,服务器禁止SAVE命令和BGSAVE命令同时执行,为了避免产生竞争.
    * 服务器禁止两个BGSAVE命令同时执行,为了避免竞争.
    * 如果BGREWRITEAOF命令正在执行,则BGSAVE命令会被服务器拒绝.为了避免性能问题.
  * 服务器在载入RDB文件期间,会一直处于阻塞状态,直到载入工作完成为止.
  * 针对不同的键值对,RDB会使用不同的方式来保存它们.
  * AOF:
    * AOF持久化是通过保存Redis所执行的写命令来记录数据库状态的.
    * 被写入AOF文件的所有命令都是以Redis的命令请求协议保存的.
    * AOF持久化功能的实现可以分为命令追加,文件写入,文件同步三个过程.
        * 命令追加: 服务器在执行完一个写命令后,会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾.
    * 为了解决AOF文件体积膨胀的问题,Redis提供了AOF文件重写功能.
    * AOF后台重写:
        * 子进程进行AOF重写期间,服务器进程可以继续处理命令请求.
        * 子进程带有服务器进程的数据副本,可以避免在使用锁的情况下,保证数据的安全性.
    * appendfync选项的不同值对AOF持久化功能的安全性以及Redis服务器的性能有很大的影响.
    * AOF重写可以产生一个新的文件,这个文件和原有的AOF文件所保存的数据库状态一样,但体积更小.
    * 在执行BGREWRITEAOF命令时,Redis服务器会维护一个AOF重写缓冲区.
2. Redis的RDB持久化为什么要fork一个子进程来实现:
    * 父进程继续处理client请求,子进程负责将内存内容写入到临时文件,由于OS写时复制机制,父子进程会共享相同的物理页面,当父进程处理写请求时,
    OS会为父进程要修改的页面创建副本,而不是写共享页面.所以子进程地址空间内的数据是fork时刻整个数据库的一个快照.
3. MySQL中的索引一定都是放在内存中的吗?
    * 索引一般是存储在索引文件中,在使用的时候才会加载到内存中.
4. MySQL为什么要用B+tree来实现数据存储?
    * B+树的数据结构有更小的磁盘I/O消耗.
    * 哈希表:
        * 哈希表这种结构适用于等值查询的场景,再做区间查询的时候就比较慢.
    * 有序数组:
        * 有序数组索引只适用于静态存储引擎.
        * 在更新数据的时候需要保证插入的顺序,成本太高.
    * 二叉搜索树:
        * 为了维持O(logn)的查询时间复杂度,需要保持这棵树是平衡二叉树.为了这个保证,更新的时间复杂度也是O(logn).
        * 大多数数据存储不使用二叉树,原因是索引不止存在于内存中,还要写到磁盘上.
    * InnoDB使用了B+树索引模型,所以数据都是存储在B+树中的.
    * 每个索引在InnoDB里对应一颗B+树.
    * 索引类型分为主键索引和非主键索引:
        * 主键索引的叶子节点存的是整行数据.
        * 非主键索引的叶子节点的内容是主键的值.
        * 非主键索引查询,需要先搜索非主键索引树,查找到主键后再到主键索引树查询,这个过程叫做回表.
    * 主键长度越小,普通索引叶子节点就越小,普通索引占用的空间就越小.
    * B+树能够很好的配合磁盘的读写特性,减少单次查询的访问磁盘次数.
5. MySQL中全文索引的实现.
    * MySQL5.6之后的版本MyIsam和InnoDB都支持全文索引.
    * 只有字段类型是char varchar和text才可以创建全文索引.
#### 0X02 好未来一面
1. MySQL的脏读和幻读:
    * 脏读: 当一个事务正在访问数据,并且对数据做了修改,而这种修改还没有提交到数据库中,这时,另外一个事务也访问了这个数据,然后使用了这个数据.
2. PHP的生命周期:
    * php_module_startup: 常量注册;PHP核心配置及Zend ini变量配置;超全局变量注册;PHP扩展注册及启动.
    * php_request_startup: gc初始化;初始化编辑器;初始化词法编辑器;php扩展启动.
    * php_execute_script: zend_execute_scripts;zend_compile_file; zend_execute zvm的执行入口.
    * php_request_shutdown: 依次调用通过register_shutdown_function注册的钩子函数;
    调用析构函数;将所有输出flush;依次调用各扩展的shutdown函数;关闭output;释放register_shutdown_function;
    销毁全局变量;关闭内存管理器.
    * php_module_shutdown: 调用sapi_flush;zend_shutdown; 清理ini HashTable元素; 销毁EG; 关闭output;
    释放PG.
3. MySQL中char, varchar和text:
    * char长度固定,即每条数据占用等长字节空间.
        * char(n)中的n表示字符数,最大长度是255个字符,如果是utf8的编码格式,char类型占255*3个字节.
    * varchar可变长度,可以设置最大长度,适合长度可变的属性.
        * varchar(n)中的n表示字符数,最大空间65535个字节,存放字符数量和字符集有关系.
        * varchar的实际范围是65532或65533,因为内容头部会占用1或2两个字节保存该字符串的长度.
    * text不设置长度,当不知道属性的最大长度时,适合使用text.
        * text占用的最大空间也是65535个字节.
4. HTTP1.0, HTTP1.1,HTTP2.0的区别:
    * HTTP1.0需要keep-alive参数来告知服务器建立一个长连接,HTTP1.1默认使用长连接.
    * HTTP2.0使用了多路复用技术,做到同一个链接并发处理多个请求.
    * HTTP1.1不支持header数据的压缩,HTTP2.0使用HPACK算法对header的数据进行压缩,这样体积小了,在网络传输上也就更快.
5. 进程和线程的区别:
    * 进程是操作系统资源分配的基本单位.线程是任务调度和执行的基本单位.
    * 在开销方面: 每个进程有自己独立的代码和数据空间,进程之间切换会有较大的开销;线程之间切换的开销较小.
    * 内存分配: 系统在运行时会为每个进程分配不同的内存空间;线程所使用的的资源来自其所属进程的资源.
6. 进程的各种状态:
    * 三态模型:
        * 运行态(running): 进程占有处理器正在运行.
        * 就绪态(ready): 进程具备运行条件,等待系统分配处理器以便运行. 
        * 等待态(wait): 又称为阻塞态或睡眠态.指进程不具备运行的条件,正在等待某个事件的完成.
    * 五态模型:
        * 新建态: 创建一个子进程.
        * 就绪态
        * 运行态
        * 终止态
        * 等待态       
#### 0X03 自如一面
1. 二叉树遍历:
    * 前序遍历: 对于树中的任意节点来说,先打印这个节点,然后在打印它的左子树,最后打印它的右子树.
    * 中序遍历: 对于树中的任意节点来说,先打印它的左子树,然后打印它本身,最后打印它的右子树.
    * 后序遍历: 对于树中的任意节点来说,下打印它的左子树,然后在打印它的右子树,最后打印它本身.
2. static和self的区别:
    * 伪变量$this在静态方法中不可以调用.
    * 范围解析操作符: ::,可以用于访问静态成员,类常量.
    * 在类内部可以使用new self,new static,new parent创建新对象.
    * static::只能用于静态属性.
3. MySQL锁机制:
    * MySQL里面的锁大致可以分为全局锁,表级锁和行级锁三类.
        * 全局锁: 
            * 全局锁就是对整个数据库实例加锁.
            * MySQL提供了一个加全局读锁的方法,命令是Flush tables with read lock,如果需要让整个库处于只读状态时可以使用这个命令.
            * 全局锁的典型使用场景是,做全库的逻辑备份.
        * 表级锁:
            * MySQL里的表级锁有两种,一种是表锁,一种是元数据锁.
            * 表锁的语法是: lock tables ... read/write.
            * lock tables除了会限制别的线程的读写外,也限定了本线程接下来的操作对象.
            * 读锁会阻塞写,但是不会阻塞读;写锁会阻塞读和写.
            * MDL锁不需要显示的使用,在访问一个表的时候会自动加上.
            * 在MySQL5.5的版本中引入了MDL,当对一个表做增删改查操作的时候,加MDL读锁;当对表结构做变更操作的时候,加MDL写锁.
                * 读锁之间是不互斥的,因此可以多个线程同时对一张表增删改查.
                * 读写锁之间,写锁之间是互斥的,用来保证表结构变更操作的安全性.
            * 事务中的MDL锁,在语句执行开始时申请,但是语句结束后并不会马上释放,二会等到整个事务提交后释放.
            * 应用场景: 给小表加个字段,导致真个库挂了.
        * 行级锁:
            * MySQL的行锁是在引擎层由各个引擎自己实现的.
            * 在InnoDB中,行锁是在需要的时候才加上的,但并不是不需要了就立刻释放,而是要等到事务结束时才释放.
4. MySQL事务的特性:
    * 原子性: Atomicity
    * 一致性: Consistency
    * 隔离性: Isolation
    * 持久性: Durability
#### 0X04 头条一二面
1. Redis主从复制的原理:
    * Redis的复制功能可分为同步和命令传播两个操作.
    * 当客户端向从服务器发送SLAVEOF命令,要求从服务器复制主服务器时,从服务器首先要执行同步操作,即将从服务器的数据库状态更新至主服务器当前所处的数据库状态.
    * 命令传播操作用于主服务器的数据库状态被修改,导致主服务器的数据库状态不一致时,让主从服务器的数据库状态重新保持一致.
    * 同步的过程:
        * 从服务器向主服务器发送SYNC命令.
        * 收到SYNC命令的主服务器执行BGSAVE命令,在后台生成一个RDB文件,并使用一个缓冲区记录从现在开始执行的所有写命令.
        * 当主服务器的BGSAVE命令执行完毕后,主服务器将生成的RDB文件发送给服务器,从服务器接收并加载这个RDB文件,将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态.
        * 主服务器将记录在缓冲区的所有写命令发送给从服务器,从服务器执行这些写命令,将自己的数据库状态更新至主服务器当前所处的状态.
    * 命令传播过程:
        主服务器会将自己执行的那条写命令,发送给从服务器执行,当从服务器执行了该写命令后,主从服务器将再次进入到一致状态.
2. 用户态和内核态的区别:
         
         


