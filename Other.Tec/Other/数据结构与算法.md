#### 0X01 复杂度分析
1. 时间复杂度分析:
    + T(n)=O(f(n))
        + T(n): 表示代码执行的时间.
        + n: 表示数据规模的大小.
        + f(n): 表示每段代码执行的次数总和.
        + O:表示T(n)与f(n)成正比.
    + 上述公式叫做大O时间复杂度表示法.
        + 大O时间复杂度实际上并不具体表示代码真正的执行时间,而是表示代码执行时间随数据规模增长的变化趋势,也叫做渐进时间复杂度,简称
        时间复杂度.
    + 时间复杂度分析:
        + 只关注循环次数最多的一段代码.
        + 加法法则: 总复杂度等于量级最大的那段代码的复杂度.
        + 乘法法则: 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积.
        + 复杂度量级:
            + 常量阶: O(1)
            + 对数阶: O(logn)
            + 线性阶: O(n)
            + 线性对数阶: O(nlogn)
            + 平方阶: O(n^2) 立方阶: O(n^3)
            + 指数阶: O(2^n)
            + 阶乘阶: O(n!)
    + O(1): 
        + 只要代码的执行时间不随n的增大而增长,这样的代码的时间复杂度都记作O(1)
        + 一般情况下只要算法中不存在循环语句,递归语句,即使有成千上万行代码.其时间复杂度也是O(1).
    + O(logn)和O(nlogn):
        + 实际上不管是以2为底,还是以3为底,都可以把对数阶的复杂度即为O(logn),因为对数可以相互转换.
        + 如果一段代码的复杂度是O(logn),按照乘法原则,循环执行其n遍,则复杂度就是O(nlogn).
    + O(m+n) O(m*n):
        + 我们无法事先评估m和n谁的量级大,所以表示时间复杂度的时候,就不能简单的利用加法法则,省略掉其中一个.
2. 空间复杂度分析:
    + 空间复杂度全称是渐进空间复杂度,表示算法的存储空间和数据规模之间的关系.
    + 常见的空间复杂度是O(1), O(n), O(n^2).
3. 最好,最坏情况时间复杂度:
    + 最好情况时间复杂度: 在最理想的情况下,执行这段代码的时间复杂度.
    + 最坏情况时间复杂度: 在最糟糕的情况下,执行这段代码的时间复杂度.
    + 平均情况时间复杂度: 全称叫做加权平均时间复杂度或者期望时间复杂度.
    + 均摊时间复杂度: 通过摊还分析法来分析算法的时间复杂度叫均摊时间复杂度.
#### 0X02 数据结构
1. 数组:
    + 数组是一种线性数据结构.它用一组连续的内存空间,来存储一组具有相同数据类型的数据.
    + 数组支持随机访问,根据下标随机访问的时间复杂度是O(1).
    + 数组和容器:
        + Java ArrayList无法存储基本数据类型,比如int, long.需要封装为Integer,Long类.这就牵扯拆装箱的性能损耗.
        + 如果数据大小事先已知,并且对数据的操作非常简单,用不到ArrayList提供的大部分方法,可以使用数组.
        + 当要表示多维数组时,用数组会比较直观.
        + 日常来讲使用ArrayList容器就完全够用,如果需要考虑性能损耗,则就选择数组.
    + 数组下标为何从0开始:
        + 下标的最确切含义是偏移.
        + 从1开始编号,每次随机访问数组元素都多了一次减法运算.
        + 历史原因,C语言的数组是从0开始编号的,后续的语言沿用了这个设计.
2. 链表:
    + 缓存淘汰算法:
        + 常见的策略有三种:
            + 先进先出策略.FIFO
            + 最少使用策略.LFU
            + 最近最少使用策略.LRU
    + 单链表:
        + 每个链表的节点除了存储数据外,还需要记录链上下一个节点的地址.
        + 链表随机访问的性能没有数组好,需要O(n)的时间复杂度.
    + 循环链表:
        + 循环链表的尾结点是指向头结点的.
    + 双端链表:
        + 双端链表支持两个方向,每个节点不止有一个后继指针指向后面的节点,还有一个前驱指针prev指向前面的节点.
        + 双端链表相对比较浪费内存.
    + 链表VS数组:
        + 数组的缺点是大小固定,一经声明就要占用整块连续空间.
3. 栈:
    + 栈可以理解为一摞叠在一起的盘子.
    + 栈是一种操作受限的线性表,只允许一端插入和删除数据.
    + 栈既可以用数组来实现,又可以用链表来实现.用数组实现的栈叫顺序栈.用链表实现的栈叫链式栈.
4. 队列:
    + 队列是一种操作受限的线性表.
    + 用数组实现的队列叫顺序队列.用链表实现的队列叫链式队列.
    + 循环队列: 队头和队尾相连接.
5. 递归:
    + 递归需要满足的三个条件:
        + 一个问题的解可以分解为几个子问题的解.
        + 这个问题与分解之后的子问题,除了数据规模不一样,求解思路完全一样.
        + 存在递归终止条件.
    + 递归代码有很多弊端:
        + 堆栈溢出
        + 重复计算
        + 函数调用耗时多
        + 空间复杂度高
6. 排序:
    + 稳定性: 如果排序的序列中存在值相等的元素,经过排序之后,相等元素之间原有的先后顺序不变.
    + 冒泡排序:
        + 冒泡排序只会操作相邻的两个数据.每次冒泡操作都会对相邻的两个元素进行比较,看是否满足大小关系要求.
        + 冒泡的过程只涉及相邻数据的交换操作,只需要常量级的临时空间,所以它的空间复杂度是O(1).是一个原地排序算法.
        + 冒泡排序是稳定的排序算法.
        + 最坏情况的时间复杂度是O(n^2).
    + 插入排序:
        + 插入排序算法的核心思想是取未排序区间中的元素,在已排序区间中找到合适的插入位置将其插入,并保证已排序区间数据 一直有序.
        重复这个过程,直到未排序区间中元素为空,算法结束.
        + 插入排序是原地排序算法.
        + 是稳定的排序算法.
        + 最坏的时间复杂度:O(n^2).
    + 选择排序:
        + 选择排序类似于插入排序,也分为已排序区间和未排序区间.但是选择排序每次会从未排序区间中找到最小的元素,将其放到已排序区间的末尾.
        + 选择排序是原地排序算法.
        + 选择排序是不稳定的排序算法.
        + 最坏时间复杂度:O(n^2).
    + 归并排序:
        + 把数组从中间分为两部分,然后对前后两部分分别排序,在将排好序的两部分合并到一起,这样整个数组就是有序的了.
        + 归并排序是稳定的排序算法.
        + 最好和最坏的时间复杂度都是O(nlogn).
        + 归并排序不是原地排序算法,比较耗费空间.其空间复杂度是O(n),这也是其没有快速排序算法流行的原因.
    + 快速排序:
        + 如果要排序的数组中下标从p到r之间的一组数据,我们选择p到r之间的任意一个数据作为分区点.遍历p到r之间的数据,将小于分区点的数据
        放到左边,将大于分区点的数据放到右边,将分区点放到中间.最后将数据合并.
        + 快速排序不是一个稳定的排序算法.
        + 快速排序是原地排序算法.
        + 归并排序的处理过程是由上到下的,先处理子问题,然后再合并.而快排正好相反,它的处理过程是自上而下的,先分区,处理子问题,最后在合并.
        + 快排的时间复杂度是O(nlogn),在分区不均匀的情况下时间复杂度会退化到O(n^2).
    + 桶排序:
        + 将要排序的数据分到几个有序的桶里,每个桶里的数据在单独进行排序.桶内排完序后,再把桶里的数据按照顺序依次取出,组成的序列就是有序的了.
        + 桶排序对数据有很高的要求:
            + 要排序的数据要很容易的划分成m个桶,并且桶与桶之间有天然的大小顺序.
            + 数据在各个桶之间的分布是比较均匀的.
        + 桶排序比较适合用在外部排序中.外部排序就是数据存储在外部磁盘中,数据量比较大,内存有限,无法将数据全部加载到内存中.
    + 计数排序:
        + 当要排序的n个数据,所处的范围并不大的时候,比如最大值k,我们就可以把数据划分成k个桶.每个桶内的数据都是相同的,省掉了桶内排序的时间.
        + 计数排序只能给非负整数排序,要排序的数据类型中有其他类型,则无法适用.
    + 基数排序:
        + 基数排序对要排序的数据是有要求的,需要可以分隔出独立的位来进行比较,而且位之间有递进关系,每一位的数据范围不能太大.
7. 快速排序的优化:
    + 三数取中法:
        + 从区间的首,尾,中间,分别取一个数,然后对比大小,取这三个数的中间值作为分区点.
    + 随机法:
        + 每次从要排序的区间中,随机选择一个元素作为分区点.
8. 二分查找:
    + 时间复杂度: O(logn).
    + 使用场景:
        + 二分查找法依赖的是顺序表结构,简单点说就是数组.主要原因是二分查找法需要按照下标随机访问元素.
        + 二分查找针对的是有序数据.二分查找只能用在插入,删除操作不频繁,一次排序多次查找的场景中.
        + 数据量太小不适用二分查找,直接遍历查找就可以.
        + 如果数据比较比较耗时,无论数据量小与否,都最好使用二分查找实现.
        + 数据量太大也不适合二分查找.二分查找依赖于数组,数组要求连续的内存空间,对内存的要求会很高.
9. 跳表:
    + 链表加多级索引的结构就是跳表.
    + 在跳表中查询任意数据的时间复杂度是O(logn).
    + 跳表的空间复杂度是O(n).
10. 散列表:
    + 散列表用的是数组支持按照下标随机访问数据的特性,所以散列表其实就是数组的一种扩展,由数组演化而来.
    + 散列函数设计的要求:
        + 散列函数计算得到的散列值是一个非负整数.
        + 如果key1=key2,那Hash(key1)==Hash(key2).
        + 如果key1!=key2,那么Hash(key1)!=Hash(key2).
    + 散列冲突的解决办法有两个:
        + 开放寻址法.
            + 如果出现了散列冲突,就重新探测一个位置,将其插入.
            + 散列表中的元素越来越多,空闲位置就越来越少,开放寻址法的性能就会很低.
            + 可以使用二次探测法或双重散列来解决.
            + 装载因子=填入散列表中的元素个数/散列表的长度.装载因子越大,说明空闲位置越少,冲突越多,散列表的性能会下降.
        + 链表法:
            + 散列表中,每个桶或槽会对应一个链表.
    + 如何设计散列函数:
        + 散列函数的设计不能太复杂,否则会导致耗费更多的时间.
        + 散列函数生成的值要尽可能的随机和均匀.
    + 当装载因子过大时,可以进行动态的扩容,重新申请一个更大的散列表.
        + 装载因子的阈值需要选择得当.如果太大导致冲突太多;如果太小,会导致内存严重浪费.
        + 装载因子的设置需要权衡空间,时间复杂度.
    + 当数据量较小,装载因子小的时候,适合采用开放寻址法.
    + 基于链表的散列冲突处理方法比较适合存储大对象,大数据量的散列表,而且比起开发寻址法,它更加灵活,支持更多的优化策略,比如用红黑树代替链表.
    + 散列表的设计:
        + 选择一个合适的散列函数.
        + 定义装载因子阈值,并且设计动态扩容策略.
        + 选择合适的散列冲突方法.
11. 哈希算法:
    + 将任意长度的二进制值串映射为固定长度的二进制值串,这个映射的规则就是哈希算法.
    + 哈希算法的应用:
        + 唯一标示.
        + 用于校验数据的完整性和正确性.
        + 安全加密.
        + 散列函数.
12. 树:
    + 有三个比较相似的概念: 高度,深度和层.
13. 二叉树:
    + 每个节点最多有两个叉,也就是两个节点,左节点和右节点.
    + 二叉树的实现方式有两种,一种是二叉链式存储法,另一种是基于数组的顺序存储法.
        + 二叉链式存储法:
            + 每个节点有三个字段,一个用来存储数据,另外两个指向左右子节点的指针.
        + 基于数组的顺序存储法:
            + 如果节点X存储在数组中下标为i的位置,下标为2*i的位置存储的就是左子节点,下标为2*i+1的位置存储的就是右子节点.下标为i/2的位置就是
            它的父节点.
        + 二叉树的遍历:
            + 前序遍历: 对于树中的任意节点来说,先打印这个节点,然后再打印它的左子树,最后打印它的右子树.
            + 中序遍历: 对于树中的任意节点来说,先打印它的左子树,然后打印它本身,最后打印它的右子树.
            + 后序遍历: 对于树中的任意节点来说,先打印它的左子树,然后再打印它的右子树,最后打印这个节点本身.
            + 二叉树的前,中,后序遍历其实就是递归的过程.
            + 二叉树遍历的时间复杂度是O(n).
14. 二叉查找树:
    + 在树中的任意一个节点,其左子树中的每个节点的值,都要小于这个节点的值,而右子树节点的值都大于这个节点的值.
    + 二叉查找树的时间复杂度是O(n).
15. 平衡二叉查找树:
    + 二叉树中任意一个节点的左右子树的高度相差不能大于1.
16. 红黑树:
    + 是一种不严格的平衡二叉查找树.
    + 红黑树中的节点,一类被标记为黑色,一类被标记为红色.一颗红黑树还需要满足以下的条件:
        + 根节点是黑色的.
        + 每个叶子节点都是黑色的空节点,也就是说,叶子节点不存储数据.
        + 任何相邻的节点都不能同时为红色,红色节点是被黑色节点隔开的.
        + 每个节点,从该节点到达其可达节点的所有路径,都包含相同数目的黑色节点.
17. 堆排序:
    + 堆是一个完全二叉树.除了最后一层,其它层的节点个数都是满的.最后一层的节点都靠左排列.
    + 堆中每个节点的值都必须大于等于或小于等于其子树中每个节点的值.
    + 大于等于子树中每个节点值的堆,叫大顶堆.
    + 小于等于子树中每个节点值的堆,叫小顶堆.
    + 堆可以使用数组来实现,这样会更省空间.
    + 往堆中插入元素:
        + 将节点插入堆中,并且满足堆的特型,这个过程叫堆化.
        + 堆化有两种,从下往上和从上往下.
    + 堆排序的时间复杂度O(n/logn).
    