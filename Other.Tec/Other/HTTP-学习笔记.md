### HTTP学习笔记
#### 0X01 HTTP发展历史
1. HTTP始于三十年前蒂姆-博纳斯-李的一篇论文.
2. HTTP/0.9是一个文本协议,只能获取文本资源.
3. HTTP/1.0确立了大部分现在使用的技术,但不是正式标准.
4. HTTP/1.1是目前互联网使用最广泛的协议,功能也非常完善.
5. HTTP/2基于Google的SPDY协议,注重性能改善,但还未普及.
6. HTTP/3基于Google的QUIC协议,是将来的发展方向.
#### 0X02 HTTP
1. HTTP是一个在计算机世界里专门在两点之间传输文字,图片,音频,视频等超文本数据的约定和规范.
2. HTTP通常跑在TCP/IP协议之上,依靠IP协议实现寻址和路由,依靠TCP协议实现可靠的数据传输,DNS实现域名查找,SSL/TSL协议实现安全通信.
3. 互联网是万维网的一个子集.互联网基于HTTP协议传输超文本资源.
4. 两个分层模型的映射关系:
    + 第一层: 物理层, TCP/IP层无对应.
    + 第二层: 数据链路层,对应TCP/IP的链接层.
    + 第三层: 网络层,对应TCP/IP的网际层.
    + 第四层: 传输层,对应TCP/IP的传输层.
    + 第五,六,七层: 统一对应到TCP/IP的应用层.
5. 报文:
    + HTTP协议的请求报文与响应报文结构基本相同,由三大部分组成:
        + 起始行: 描述请求或响应的基本信息.
        + 头部字段集合: 使用key-value形式更详细的描述报文.
        + 消息正文: 实际传输的数据,不只是纯文本数据,也可能是图片,视频等二进制数据.
    + HTTP协议规定报文必须有header,但可以没有body.
    + 头部字段:
        + 字段名不区分大小写.
        + 字段名不允许出现空格,可以使用连字符"-".
        + 字段名后面必须紧跟冒号":".
        + 字段的顺序是无意义的,可以任意排列不影响语义.
        + 字段原则上不能重复,除非这个字段语义上允许重复.
    + 常用头字段:
        + 通用字段: 响应头和请求头都可以出现.
            + Date字段: 表示报文创建的时间.
        + 请求字段: 只能在请求头中出现的字段.
            + Host字段请求头必须出现,否则报文是错误报文.
            + 
        + 响应字段: 只能在响应头中出现的字段.
        + 实体字段: 属于通用字段,专门用于描述body的额外信息.
            + Content-Length: 表示报文中body的长度,如果没有这个字段,body就是不定长,需要使用chunked方式传输.
    + URI:
        + 格式: schema://host:port/path?query#fragment
    + 状态码:
        + 1XX: 提示信息,是协议处理的中间状态. 如: 101 switch protocol: 客户端使用upgrade头字段,要求改用其他协议继续通信.
        + 2XX: 表示服务器收到并正确处理了客户端的请求.
            + 204 No Content: 响应头后没有body数据.
            + 206 Partial Content: 分块下载或断点续传的基础.body里面的数据不是资源的全部,而是其中的一部分.
            状态码206通常还会伴随一个头字段,Content-Range,表示响应报文里body数据的具体范围.Content-Range:bytes 0-99/2000.
        + 3XX: 表示客户端请求的资源发生了变动.
            + 301 Moved Permanently: 永久重定向.  
            + 302 Found: 临时重定向.
            + 304 Not Modified: 用于缓存控制.
        + 4XX: 表示客户端发送的请求报文有误,服务器无法处理.
            + 400 Bad Request: 表示报文错误, 服务器无法处理.
            + 403 Forbidden: 表示服务器资源禁止访问.
            + 404 Not Found: 资源找不到.
            + 405 Method Not Allowed: 表示不允许某些方法操作服务器资源.
            + 406 Not Acceptable: 资源无法满足客户端请求的条件.
            + 408 Request Timeout: 请求超时,服务器等待了过长时间.
            + 409 Conflict: 多个请求发生了冲突,可以理解为多线程的竟态.
            + 413 Request Entity Too Large.
            + 414 Request-URI Too Long.
            + 429 Too Many Requests.
            + 431 Request Headers Fields Too Large.
        + 5XX: 表示服务器在处理时,内部发生错误,是服务器端的错误码.
            + 500 Internal Server Error.通用的错误码,表示服务器内部错误.
            + 501 Not Implemented: 表示客户端请求的功能还不支持.
            + 502 Bad Gateway: 表示服务器本身工作正常,但是访问后端服务时发生错误.
            + 503 Service Unavailable: 服务暂时不可用,通常还会搭配Retry-After字段使用.
    + 数据类型与编码:
        + Accept字段标记的是客户端可理解的MIME Type,可以用逗号分隔多个类型.响应报文中会使用Content-Type来告诉实体数据
        真实的类型.
        + Accept-Encoding字段标记的是客户端支持的压缩格式.,使用逗号隔开多个.
        响应都中使用Content-Encoding告诉客户端真实的压缩类型.
        + Accept-Language字段标记客户端可理解的自然语言,多个使用逗号进行分隔.
        响应报文中使用Content-Language告诉客户端真实语言.
        + 内容协商质量值:
            + Accept,Accept-Encoding,Accept-Language可以使用分号+q=数值来设定优先级.
            + 权重的最大值是1,最小值是0.01,默认值是1.如果值是0就表示拒绝.
            + 例如: Accept: text/html,application/xml;q=0.9,\*/\*;q=0.8
        + 内容协商的结果:
            + Vary字段记录服务器在内容协商时参考的请求头字段.
            + 例如: Vary: Accept-Encoding,User-Agent,Accept
6. 大文件传输:
    + 分块传输:
        + Transfer-Encoding:chunked和Content-Length两个字段是互斥的,响应报文中不能同时出现这两个字段.
        + 编码规则:
            + 每个分块包含两个部分,长度头和数据块.
            + 长度头是以CRLF结尾的一行明文,用16进制数字表示长度.
            + 数据库紧跟在长度头后,最后也用CRLF结尾,但数据不包含CRLF.
            + 最后一个数据为0的块表示结束.            
    + 范围请求:
        + 服务器在响应头中使用Accept-Range:bytes明确告知客户端是支持范围请求的.
        + 如果不支持,响应头中发送Accept-Range:none.
        + 请求头: Range: bytes=0-31
        + 响应头: Accept-Ranges: bytes Content-Range: bytes 0-31/90
        注: bytes是从0开始的.
        + 多个分段:
            + 范围请求还支持在Range头里使用多个x-y,一次性获取多个片段数据.
            这种情况需要标明body的类型是multipart/byteranges还需要使用boundary=xx给出段之间的分隔标记.
7. 连接管理:
    + HTTP1.1的所有连接默认都会启用长连接.
    + 如果需要显式指定需要使用长连接,在请求头中加入字段: Connection: Keep-Alive.
    如果服务器端支持长连接,会在响应头中加入Connection: Keep-Alive.
    + 在客户端,可以使用Connection: close来关闭长连接.
    + 服务器端也会有些策略来关闭长连接.比如Nginx:
        + 使用keepalive_timeout指令,设置长连接的超时时间,如果在一段时间内没有发生数据收发就主动断开连接.
        + 使用keepalive_requests指令,设置长连接上可以发送的最大请求次数.
    + 队头阻塞问题会导致性能下降,可以用并发连接和域名分片技术缓解.
    + Connection: Upgrade,配合状态码101使用,表示协议切换升级.
8. 重定向和跳转:
    + Location字段属于响应字段,必须出现在响应报文里.但只有配合301/302状态码才有意义,它标记了服务器要求重定向的URI.
    + 重定向是服务器发起的跳转,要求客户端改用新的URI重新发送请求,通常是自动进行的,用户是无感知的.
    + 重定向报文里可以使用Refresh字段实现延时重定向.Refresh:5;url=xxx.
9. Cookie:
    + 响应头中通过Set-Cookie字段设置Cookie,请求头通过Cookie字段携带cookie信息.
    + Cookie的有效期可以使用Expires和Max-Age两个字段来设置.Expires是绝对时间,可以理解为截止时间.Max-Age是相对时间,单位是秒.浏览器收到报文的时间点加上Max-Age就可以得到失效时间.
    + Express和Max-Age可以同时出现,两者的失效时间可以一致,也可以不一致,浏览器会优先使用Max-Age来判断失效时间.
10. 缓存控制:
    + 服务器标记资源有效期使用的头字段是Cache-Control,里面的值max-age=30就是资源的有效时间,单位是秒.(只能缓存30s,过了30s就会过期)
        + max-age是生存时间,时间的计算起点是响应报文创建的时刻(即Date字段,也就是离开服务器的时刻)
        + no-store: 不允许缓存,用于某些变化非常频繁的页面.
        + no-cache: 可以缓存,但是使用前必须去服务器验证是否过期,是否是最新版本.
        + must-revalidate: 如果缓存不过期就可以继续使用,但过期了如果还想使用就必须去服务器验证.
    + 当点击刷新按钮时,浏览器会发送Cache-Control:max-age=0,来获取最新的数据.
    + Ctrl+F5刷新浏览器会发送Cache-Control:no-cache.和max-age=0的效果是相同的.
    + 条件请求:
        + 条件请求一共有五个字段,最常用的是If-Modify-Since和If-None-Match,但是需要前一次的响应报文预先提供
        Last-Modified和ETag,然后第二次请求就可以带上缓存里的原值,验证资源是否是最新的.
        + Last-Modified:文件最后的修改时间.
        + ETag: 是实体标签的缩写(Entity Tag).是资源的唯一标识,主要是用来解决修改时间无法准确区分文件变化的问题.
            + 强ETag要求资源在字节级别必须相符.
            + 弱ETag在值前有个W/标记,只要求资源在语义上没有变化,但内部可能会有部分发生了变化.
    + 如果响应报文里提供了Last-Modified,但没有Cache-Control或Expires,浏览器会使用启发算法,计算一个缓存时间
    RFC里的建议是(Date - Last-Modified)*10%.
    + 代理服务:
        + Via字段是一个通用字段,请求头和响应头都可以使用,每当报文经过一个代理节点时,代理服务器就会把自身的信息追加到字段的末尾
        多个使用逗号分隔.主要追加代理的主机名或者域名.
        + X-Forwarded-For: 追加请求方IP,所以最左端的IP就是客户端的IP.
        + X-Real-IP:记录客户端ip.
11. 缓存代理:
    + Cache-Control字段里常用的值: 
        + private: 缓存只能在客户端保存,是用户私有的.
        + public: 缓存完全开放,谁都可以存,谁都可以用.
        + s-maxage: 只限定在代理上能够存多久,而在客户端上仍然使用max-age.
        + no-transform: 不允许代理对缓存数据做任何处理.
        + max-stale: 如果代理上的缓存过期了也可以接受,但不能过期太多.
        + min-fresh=1:绝对不允许过期.
#### 0X03 HTTPS
1. HTTPS把HTTP下层的传输协议由TCP/IP协议换成了SSL/TLS,收发报文调用专门的安全接口.
2. SSL是安全套接层,在OSI模型中处于会话层.
3. 对称加密:
    + 加密和解密使用的秘钥都是同一个.比如AES.
4. 非对称加密:
    + 非对称加密有两个密钥,一个公钥,一个私钥.两个密钥不同,所以是非对称的.公钥可以给任何人使用,私钥必须严格保密.
    + 公钥和私钥都有单向性,公钥加密只能用私钥解密,私钥加密只能用公钥解密.
    + 非对称加密可以解决密钥交换的问题.
5. 数字签名与证书:
    + 摘要算法:
        + 把任意长度的数据压缩成固定长度,而且是独一无二的摘要字符串.摘要算法是单向的加密,无法解密,没有密钥.
        + 摘要算法保证数字摘要和原文是完全等价的.但是原文不能被窃取,原文必须也进行加密传输.
    + 数字签名:
        + 用私钥加密,公钥解密,如果可以解密,则可以验明对方的身份.
    数字证书:
        + 数字证书是有第三方的证书机构进行颁发.
        + 签发的证书分DV,OV,EV三种,区别在于可信度.
            + DV: 只是域名级别的可信,背后是谁不知道.
            + EV: 是最高级别的,经过了法律和审计的严格审查.
        + 小一点的CA可以让大CA签名认证,但链条的最后是Root CA,也就是根证书或自签名证书.
6. HTTPS/TLS的握手:
    + HTTPS协议会先与服务器执行TCP握手,然后执行TLS握手,才能建立安全连接.
    + 握手的目标是安全的交换对称密钥,需要三个随机数,第三个随机数Pre-Master必须加密传输,不能让破解.
    + Hello消息交换随机数,Key Exchange消息交换Pre-Master.
    + Change Cipher Spec之前传输的都是明文,之后都是对称加密的密文.
    + HTTPS的迁移:
        + 使用301让HTTP访问全部跳转至HTTPS.
        + HSTS(HTTP严格传输安全)可以告诉浏览器强制使用HTTPS进行访问.  
         
                        
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
                