### HTTP缓存

> Web缓存是可以自动保存常见文档副本的HTTP设备。
>
> 缓存减少了冗余的数据传输。
>
> 缓存缓解了网络瓶颈问题。
>
> 缓存降低了对原始服务器的要求。
>
> 缓存降低了距离时延。

##### 0X01 冗余的数据传输

1. 服务器的文件数据会缓存在客户端，这样可以减少那些流入/流出原始服务器的，被浪费掉的重复流量。

##### 0X02 带宽瓶颈

1. 本地网络客户端提供的带宽要高于远程服务器提供的。

##### 0X03 瞬间拥塞

1. 缓存在破坏瞬间拥塞时显得非常重要。突发事件使很多人几乎同时去访问一个web文档时，就会出现瞬间拥塞。

##### 0X04 距离时延

1. 距离会给网络请求带来时延。距离越远，时延越大。

##### 0X05 命中和未命中的

1. 用已有的副本为某些到达缓存的请求提供服务，这被称为缓存命中。
2. 到达缓存的请求可能会由于没有副本可用，而被转发给袁辉服务器。这被称为缓存未命中。

##### 0X05.1 再验证

1. 原始服务器的内容可能会发生变化，缓存要不时对其进行检测，看看它们保存的副本是否仍是服务器上的最新副本。这些‘新鲜度检测’被称为HTTP再验证。
2. 缓存对缓存的副本进行再验证时，会向原始服务器发送一个小的再验证请求。如果内容没有变化，服务器会以一个小的304 Not Modified进行响应。这被称作再验证命中。这比缓存未命中快一些。
3. HTTP为我们提供了用来对已缓存对象进行再验证的工具，但最常用的是If-Modified-Since首部。这个首部添加到GET请求中去，就可以告诉服务器，只有缓存了对象的副本后，又对其进行了修改的情况下，才发送此对象。
4. 3种服务器收到If-Modified-Since请求时的情况：
   * 再验证命中
     * 如果服务器对象未被修改，服务器会向客户端发送一个小的HTTP 304 Not Modified响应。
   * 再验证未命中
     * 如果服务器对象与已缓存副本不同，服务器向客户端发送一条普通的，带有完整内容的HTTP 200 OK响应。
   * 对象被删除
     * 如果服务器对象已经被删除，服务器就回送一个404 Not Found响应，缓存也会将其副本删除。

##### 0X05.2 命中率

1. 由缓存提供服务的请求所占的比例被称为缓存命中率。命中率在0~1之间，通常用百分数来描述。对现在中等规模的web缓存来说，40%的命中率是很合理的。

##### 0X05.3 字节命中率

1. 字节命中率表示的是缓存提供的字节在传输的所有字节中所占的比例。
2. 文档命中率和字节命中率对缓存性能的评估都是很有用的。

##### 0X05.4 区分命中和未命中的情况

1. HTTP中没有为用户提供一种手段来区分响应是缓存命中的，还是访问原始服务器得到的。在这两种情况下，响应码都是200 OK。
2. 客户端有一种方法可以判断响应是否来自缓存，就是使用Date首部，将响应中Date首部的值与当前时间进行比较，如果响应中的日期比较早，客户端通常就可以认为这是一条缓存的响应。
3. 客户端也可以通过Age首部来检测缓存的响应，通过这个首部可以分辨出这条响应的试用期。

##### 0X06 缓存的拓扑结构

1. 专用缓存被称为私有缓存(private cache).私有缓存是个人的缓存，包含了单个用户最常用的页面。
2. 共享的缓存被称为共有缓存(public cache)。公有缓存中包含了某个用户团体的常用页面。

##### 0X06.1 私有缓存

1. Web浏览器中有内建的私有缓存。

##### 0X06.2 公有代理缓存

1. 公有缓存是特殊的共享代理服务器，被称为缓存代理服务器或被称为代理缓存。
2. 代理缓存会从本地缓存中提供文档，或者代表用户与服务器进行联系。
3. 公有缓存会接受来自多个用户的访问，所以通过它可以更好地减少冗余流量。

##### 0X06.3 代理缓存的层次结构

1. 在这种结构中，在较小缓存中未命中的请求会被导向较大的父缓存。其基本思想是在靠近客户端的地方使用小型廉价缓存，而更高层次中，则逐步采用更大、功能更强的缓存来装载多用户共享文档。

##### 0X06.4 网状缓存、内容路由以及对等缓存

1. 网状缓存中为内容路由设计的缓存要完成下列所有功能：
   * 根据URL在父缓存或原始服务器之间进行动态选择。
   * 根据URL动态地选择一个特定的父缓存。
   * 前往父缓存之前，在本地缓存中搜索已缓存的副本。
   * 允许其他缓存对其缓存的部分内容进行访问，但不允许因特网流量通过它们的缓存。
2. 缓存之间这些更为复杂的关系允许不同的组织互为对等实体，将它们的缓存连接起来以实现共赢。提供可选的对等支持的缓存被称为兄弟缓存。
3. HTTP并不支持兄弟缓存，所以人们通过一些协议对HTTP进行了扩展，比如：因特网缓存协议(ICP)和超文本缓存协议(HTCP).

##### 0X07 缓存的处理步骤

1. 缓存的处理过程：
   * 接收—缓存从网络中读取抵达的请求报文。
   * 解析—缓存对报文进行解析，提取出URL和各种首部。
   * 查询—缓存查看是否有本地副本可用，如果没有，就获取一份副本。
   * 新鲜度检测—缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新。
   * 创建响应—缓存会用新的首部和已缓存的主体来构建一条响应报文。
   * 发送—缓存通过网络将响应发回给客户端。
   * 日志—缓存可选地创建一个日志文件条目来描述这个事务。
2. 第一步—接收
   * 缓存检测到一条网络连接上的活动，读取输入数据。高性能的缓存会同时从多条输入连接上读取数据，在整条报文抵达之前开始对事物进行处理。
3. 第二步--解析
   * 缓存将请求报文解析为片断，将首部的各个部分放入易于操作的数据结构中。
4. 第三步--查找
   * 缓存获取了URL，查找本地副本。
   * 本地副本可能缓存在内存、本地磁盘，甚至附近的另一台计算机中。
   * 已缓存的对象中包含了服务器响应主体和原始服务器响应首部，这样就会在缓存命中时返回正确的服务器首部。
   * 已缓存对象中还包含了一些元数据，用来记录对象在缓存中停了的多长时间，以及它被用过多少次。
5. 第四步—新鲜度检测
   * HTTP通过缓存将服务器文档的副本保留一段时间。
   * 在这段时间里，都认为文档是新鲜的，缓存可以在不联系服务器的情况下，直接提供该文档。
   * 一旦已缓存副本停留的时间太长，超过了文档的新鲜度限值，就认为对象过时了，在提供该文档之前，缓存需要再次与服务器进行确认。
6. 第五步--创建响应
   * 缓存将已缓存的服务器响应首部作为响应首部的起点。然后缓存对这些基础首部进行了修改和扩充。
   * 缓存还会向其中插入新鲜度信息(cache-control,Age以及Expires首部)
   * 注：缓存不应该调整Date首部。Date首部表示的是原始服务器最初产生这个对象的日期。
7. 第六步--发送
   * 一旦响应首部准备好了，缓存就将响应回送给客户端。
8. 第七步--日志
   * 大多数缓存都会保存日志文件以及缓存的使用有关的一些统计数据。
   * 最常见的缓存日志格式为Squid日志格式和网景的可扩展通用日志格式。

##### 0X07.1 保存副本的新鲜度

1. HTTP有一些简单的机制可以在不要求服务器记住有哪些缓存拥有其文档副本的情况下，保持已缓存数据与服务器数据之间充分一致。HTTP将这些简单的机制称为文档过期和服务器再验证。
2. 文档过期：
   * 通过特殊的HTTP Cache-Control首部和Expires首部，HTTP让原始服务器向每个文档附加了一个“过期日期”。
   * 在缓存文档过期之前，缓存可以以任意频率使用这些副本，而无需与服务器联系。
3. 过期日期和使用期：
   * 服务器用HTTP/1.0+的Expires首部或HTTP/1.1的Cache-Control:max-age响应首部来指定过期日期，同时还会带有响应主体。
   * Expires使用的绝对日期依赖于计算机时钟的正确设置。
4. 服务器再验证：
   * HTTP协议要求行为正确的缓存返回下列内容之一：
     * 足够新鲜的已缓存副本；
     * 与服务器进行过再验证，确认其仍然新鲜的已缓存副本；
     * 如果需要与之进行再验证的原始服务器出故障了，就返回一条错误报文；
     * 附有警告信息说明内容可能不正确的已缓存副本。
5. 用条件方法进行再验证
   * HTTP允许缓存向原始服务器发送一个“条件GET”，请求服务器只有在文档与缓存中现有的副本不同时，才回送对象主体。
   * 向GET请求报文中添加一些特殊的条件首部，就可以发起条件GET。只有条件为真时，web服务器才会返回对象。
   * HTTP定义了5个条件请求首部。对缓存再验证来说最有用的2个首部是If-Modified-Since和If-None-Match.
     * If-Modified-Since:<date>如果从指定日期之后文档被修改过了，就执行请求的方法，可以与Last-Modified服务器响应首部配合使用。
     * If-None-Match:<tags>服务器可以为文档提供特殊的标签。如果已缓存标签与服务器文档中的标签有所不同，If-None-Match首部就会执行所请求的方法。
6. If-Modified-Since:Date再验证
   * If-Modified-Since再验证请求通常被称为IMS请求。只有在自某个日期之后资源发生了变化的时候，IMS请求才会指示服务器执行请求。
   * 如果自指定日期后，文档被修改了，If-Modified-Since条件就为真，通常GET就会被成功执行。携带新首部的新文档会被返回给缓存，新首部除了其他信息之外，还包含了一个新的过期日期。
   * If-Modified-Since首部可以与Last-Modified服务器响应首部配合工作。
7. If-None-Match：实体标签再验证
   * 有些情况下仅使用最后修改日期进行再验证是不够的。
     * 有些文档可能会被周期性地重写，但内容未变化。修改日期会改变。
     * 有些文档可能被修改了，但所做修改并不重要。
     * 有些服务器无法准确地判定其页面的最后修改时间。
     * 有些服务器提供的文档会在亚秒间隙发生变化，对这些服务器来说，以秒为粒度的修改日期就不够用了。
   * 实体标签是附加到文档上的任意标签。它们可能包含了文档的序列号或版本名，或者是文档内容的校验及其他指纹信息。
8. 强弱验证器
   * 实体标签和最近修改日期都是缓存验证器。
   * HTTP/1.1支持弱验证器。
   * 服务器会用前缀'W/'来标示弱验证器。Etag:W/"v2.6" If-None-Match:W/"v2.6"
   * 如果服务器回送了一个实体标签，HTTP/1.1客户端就必须使用实体标签验证器。如果服务器只回送了一个Last-Modified值，客户端就可以使用If-Modified-Since验证。如果实体标签和最后修改日期都提供了，客户端应该使用这两种再验证方式。

##### 0X07.2 控制缓存的能力

1. 服务器可以通过HTTP定义的几种方式来指定在文档过期之前可以将其缓存多长时间。按照优先级递减的顺序：
   * 附加一个Cache-Control:no-store首部到响应中去；
   * 附加一个Cache-Control:no-cache首部到响应中去；
   * 附加一个Cache-Control:must-revalidate首部到响应中去；
   * 附加一个Cache-Control:max-age首部到响应中去；
   * 附加一个Expires日期首部到响应中去；
   * 不附加信息，让缓存确定自己的过期日期。

2. no-Store与no-Cache响应首部

   * no-store首部和no-cache首部可以防止缓存提供未经证实的已缓存对象：

     Pragma:no-cache

     Cache-Control:no-store

     Cache-Control:no-cache

   * 标示为no-store的响应会禁止缓存对响应进行复制。缓存通常会像非缓存代理服务器一样，向客户端转发一条no-store响应，然后删除对象。

   * 标示为no-Cache的响应实际是可以存储在本地缓存区中的。只是在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。

3. max-age响应首部

   * Cache-Control:max-age首部表示的是从服务器将文档传来之时起，可以认为此文档处于新鲜状态的秒数。
   * Cache-Control: max-age=3600、Cache-Control: s-maxage=3600(仅适用公有缓存)
   * Cache-Control: max-age=0、Cache-Control: s-maxage=0(每次访问都进行刷新)

4. Expires响应首部

   * 不推荐使用Expires首部，它指定的是实际的过期日期而不是秒数。

5. must-revalidate响应首部

   * 在事先没有跟原始服务器进行再验证的情况下，不能提供这个对象的陈旧副本。缓存仍然可以随意提供新鲜的副本。
   * 如果在缓存进行must-revalidate新鲜度检查时，原始服务器不可用，缓存就必须返回一条504 Gateway Timeout错误。

6. 试探性过期

   * LM-Factor算法将最后修改日期作为依据，来估计文档有多么易变。
     * 如果已缓存的文档最后一次修改发生在很久以前，他可能会是一份稳定的文档，不太会突然发生变化。
     * 如果已缓存的文档最近被修改过，就说明它很可能会频繁的发生变化，因此在与服务器进行再验证之前，只应该将其缓存很短的一段时间。

7. 客户端的新鲜度限制

   * Cache-Control: no cache Pragma: no-cache 除非资源进行了再验证，否则这个客户端不会接受已缓存的资源。

##### 0X07.3 设置缓存控制

1. 控制Apache的HTTP首部：
   * mod_headers:通过mod_headers模块可以对单独的首部进行设置。
   * mod_expires:可以自动生成带有正确过期日期的Expires首部。

##### 0X07.4 详细算法

1. 使用期和新鲜生存期
   1. 为了分辨已缓存文档是否足够新鲜，缓存只需要计算两个值：已缓存副本的使用期和新鲜生存期。
   2. 使用期：自服务器将其发送出来后“老去”的总时间。
   3. 新鲜生存期：已缓存副本在不能提供给客户端使用之前能够存在的时间长度。

##### 0X07.5 广告

1. RFC 2227,‘HTTP的简单命中技术和使用限制’中定义了一种简单的方案。这个协议向HTTP中添加了一个称为Meter的首部，这个首部会周期性地将对特定URL的命中次数回送给服务器。通过这种方式，服务器可以从缓存周期性的获取对已缓存文档命中次数的更新。