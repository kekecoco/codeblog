####MySQL学习杂记
#####0X01 联合索引
1. 定义: 是指对表中的多个列创建索引,其创建方法与单个索引相同,只不过有多个索引列.单列索引可以看做是联合索引元素为1的特例.
2. 本质上来说, 联合索引是一颗B+tree,只不过键值数量不是1,而是大于1的.
3. 最左前缀的原则: 即最左优先.
如果有一个2列的索引(col1,col2),则已经对(col1), (col1, col2)建立了索引.
如果有一个3列索引(col1, col2, col3), 则已经对(col1), (col1, col2), (col1,col2,col3)建立了索引.

#####0X02 覆盖索引
1. 定义: 如果一个索引包含或者说覆盖所有需要查询的字段的值,我们就称为覆盖索引.
2. 由于InnoDB是聚集索引,覆盖索引多InnoDB特别有用.InnoDB的二级索引在叶子节点中保存了行的主键值,所以如果二级索引能够覆盖查询,则可以避免对索引的二次查询.
3. 不是所有类型的索引都能称为覆盖索引.覆盖索引必须要存储索引列的值, 而哈希索引,空间索引和全文索引都不存储索引列的值,索引MySQL只能使用B-tree索引做覆盖索引.
4. 当发起一个索引查询时,在EXPLAIN的extra列会看到"Using Index".
5. MySQL不能再索引中执行LIKE操作,只允许做最简单的比较操作(比如 等于,大于以及不等于).如果做最左前缀的LIKE操作是可以进行的,但是有通配符的LIKE操作是无法进行匹配的.

#####0X03 MySQL基础架构
1. MySQL可以分为Server层和存储引擎层两部分.
    + Server层包括: 连接器, 查询缓存, 分析器, 优化器和执行器等部分,还有内置函数,所有跨存储引擎的功能都在这一层.
    + 存储引擎负责数据的存储和读取.
2. 连接器:
    + 长连接是指连接成功后,如果客户端持续持有一个请求,则一直使用一个连接.
    + 短连接是指每次执行完很少的几次查询就断开连接,下次连接在重新建立一个连接.
    + 有些时候MySQL占用内存涨的特别快,这是因为MySQL在执行的过程中临时使用的内存是管理在连接对象里面的.这些资源会在连接断开的时候释放.所以如果长连接累计下来,可能导致内存占用过大,被系统强行杀掉.
3. 查询缓存:
    + 查询缓存失效的特别频繁,只要对一个表进行更新,这个表上所有的查询缓存都会被清空.
4. 分析器:
    + 分析器会先做词法分析,识别关键词,做完了这些识别以后,就要做语法分析.
5. 优化器:
    + 优化器是在表里面有多个索引的时候,决定使用哪个索引;或者在一个语句 有多表关联的时候,决定各个表的连接顺序.
6. 执行器:
    + 在执行一条语句之前,会先查询是否对这张表有操作权限.
7. 一条语句是如何更新的:
    + 更新操作涉及两个重要的日志: redo log(重做日志)和binlog(归档日志).
        + redo log:
            + 当有一条记录需要更新时,InnoDB引擎就会先把记录写到redo log里,并更新内存,这个时候更新就算完成了.
            + InnoDB的redo log是固定大小的,比如可以配置一组四个文件,每个文件1GB.从头开始写,写到末尾就回到开头循环写.
            + write pos是当前记录的位置,一边写一边后移.check point是当前需要擦除的位置,擦除记录前需要将记录更新到磁盘上.
            + write pos和check point之间的部分是可以进行更新操作的部分.
            + 有了 redo log,InnoDB可以保证在数据发生异常重启之后,之前提交的记录都不会丢失.
        + 两个日志之间的不同:
            + redo log是InnoDB存储引擎特有的;binlog是MySQL的server层实现的,所有存储引擎都可以使用.
            + redo log是物理日志,记录的是"在某个数据页上做了什么修改";binlog是逻辑日志,记录的是这个语句的原始逻辑.
            + redo log是循环写的,空间固定是会用完的;binlog是会追加写入的.追加写是指binlog在写完一个日志后会切换到另一个文件,不会覆盖上一个文件.
    + 两阶段提交:
        + redo log和binlog都可以用于表示事务的提交状态,而两阶段提交就是让两个状态保证逻辑上的一致.
    + innodb_flush_log_at_trx_commit这个参数设置为1的时候,表示每次事务的redo log都直接持久化到磁盘上.这个参数可以保证,MySQL异常重启后,数据不会丢失.
    + sync_binlog这个参数设置为1时,表示每次事务的binlog都持久化到磁盘.
8. 事务:
    + 在MySQL中,事务支持是在引擎层实现的.
    + SQL标准的隔离级别:
        + 读未提交: 一个事务还未提交时,它做的变更就可以被别的事务看到.
        + 读提交: 一个事务提交后,才能被其他事务看到.
        + 可重复读: 一个事务执行时看到的数据,总是和这个事务启动时看到的一样. 
        + 串行化: 对于同一行记录,写会加写锁,读会加读锁,后访问的事务必须等前一个事务执行完毕,才能继续执行.
        + 在实现上,数据库里面会创建一个视图,访问的时候以视图的逻辑结果为准.
            + 在可重复读隔离级别下,这个视图是在事务启动时创建的,整个事务存在期间都用这个视图.
            + 在读提交隔离级别下,这个视图是每个SQL语句开始执行的时候创建的.
            + 读未提交隔离级别下,直接返回记录上的最新值,没有视图概念.
            + 串行化隔离级别用直接加锁的方式来避免串行访问.
    + 事务隔离级别配置: transaction-isolation.
    + 事务的启动方式:
        + 显式的启动事务的语句,begin或start Transaction.配套的提交语句是commit,回滚语句是roll back.
        + set autocommit=0,这个命令会将这个线程的自动提交关掉.意味着如果你只执行一个select语句都会启动事务,而且这个事务不会自动提交.这个事务一直持续到主动执行commit或rollback语句,或者链接断掉.
9. 索引
    + 在InnoDB里,主键索引又被称为聚簇索引.
    + 重建索引的做法是合理的,可以达到省空间的目的.不论是删除主键还是创建主键都会使整个表重建.
10. 全局锁和表锁:
    + 全局锁: 对整个数据库实例加锁.
        + MySQL提供了一个加全局读锁的方法, Flush tables with read lock.
        + 全局锁的使用场景是做全库的逻辑备份.
        + mysqldump的single-transaction适用于支持事务的存储引擎,而像myIsam就只能使用加全局锁的方式进行数据备份.
    + 表级锁: 
        + MySQL里的表级锁有两种: 一种是表锁,一种是元数据锁(meta data lock, MDL)
        + 表锁:
            + 语法: lock tables ... read/write,可以使用unlock tables主动释放锁.
            + lock tables除了限制其他线程的读写外,也限定了本线程接下来的操作.
        + MDL锁:
            + MDL锁不需要显式使用,在访问一个表的时候会被自动加上.
            + 当对一个表做增删改查操作的时候,加MDL读锁;当要对表做结构变更,加MDL写锁.
            + 读锁之间不互斥.
            + 读写锁之间,写锁之间是互斥的,用来保证变更表结构的安全性.          
11. 行锁:
    + 死锁:
        + 在InnoDB中,innodb_lock_wait_timeout=50s.设置发生死锁的超时时间.
        + innodb_deadlock_detect=on,主动死锁检测.
    + 如果事务中,需要锁多个行,要把最可能造成锁冲突最可能影响系统并发度的锁的申请时间往后放.
      



























