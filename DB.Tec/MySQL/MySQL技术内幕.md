#### MySQL技术内幕 InnoDB存储引擎

##### 第1章 MySQL体系结构和存储引擎

1.1 数据库和实例

1. 数据库：物理操作系统文件或其他形式文件类型的集合。
2. 数据库实例：由数据库后台进程/线程一级一个共享内存区组成。共享内存可以被运行的后台进程/线程所共享。
3. 在MySQL中，数据库和实例的关系是一一对应的。
4. MySQL被设计为一个单进程多线程架构的数据库，数据库实例在系统上的表现就是一个进程。
5. MySQL是按/etc/my.cnf—>/etc/mysql/my.cnf—>/usr/local/mysql/etc/my.cnf—>~/.my.cnf的顺序读取配置文件的。MySQL会以读取到的最后一个配置文件的参数为准。

1.2 MySQL的体系结构

1. MySQL由以下几部分组成：
   * 连接池组件
   * 管理服务和工具组件
   * SQL接口组件
   * 查询分析器组件
   * 优化器组件
   * 缓冲组件
   * 插件式存储引擎
   * 物理文件
   * *MySQL区别于其他数据库的最重要的特点就是插件式的表存储引擎。（存储引擎是基于表的）*

1.3 MySQL表存储引擎

1. InnoDB存储引擎支持事务，主要面向在线事务处理(OLTP)方面的应用.
2. 特点：行锁设计、支持外键，并支持非锁定读。
3. InnoDB存储引擎将数据放在一个逻辑的表空间中。
4. InnoDB通过使用多版本并发控制(MVCC)来获得高并发性。

##### InnoDB存储引擎

1. InnoDB有多个内存块，主要负责如下工作：
   * 维护所有进程/线程需要访问的多个内部数据结构。
   * 缓存磁盘上的数据，方便快速地读取，并且在对磁盘文件的数据进行修改之前在这里缓存。
   * 重做日志缓冲。
2. 默认情况下，InnoDB存储引擎的后台线程有7个—4个IO thread，1个master thread，1个锁(lock)监控线程，1个错误监控线程。IO thread的数量由配置文件中的innodb_file_io_threads参数控制，默认为4.
3. 4个IO线程分别是insert buffer thread,log thread,read thread,write thread.
4. InnoDB存储引擎内存由以下几部分组成：缓冲池(buffer pool)，重做日志缓冲池(redo log buffer)以及额外的内存池(additional memory pool)，分别由配置文件中的参数innodb_buffer_pool_size和innodb_log_buffer_size的大小决定。
5. 缓冲池是占最大块内存的部分，用来存放各种数据的缓存。因为InnoDB的存储引擎的工作方式总是将数据库文件按页读取到缓冲池，然后按最近最少使用的算法来保留在缓冲池中的缓存数据。如果数据库文件需要修改，总是首先修改在缓冲池中的页，然后在按照一定的频率将缓冲池的脏页刷新到文件。可以通过命令 show engine innodb status来查看innodb_buffer_pool的具体使用情况。
6. 缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲、自适应哈希索引、InnoDB存储的锁信息、数据字典等。
7. master thread：
   * master thread的线程优先级别最高。其内部有几个循环组成：主循环、后台循环、刷新循环、暂停循环。
   * loop称为主循环，其中有两大部分操作：每秒钟的操作和每10秒的操作。
   * 每秒一次的操作：
     * 日志缓冲刷新到磁盘，即使这个事务还没有提交(总是)。
     * 合并插入缓冲(可能)。
     * 至多刷新100个InnoDB的缓冲池中的脏页到磁盘(可能).
     * 如果当前没有用户活动，切换到background loop(可能)。
   * 每10秒一次的操作：
     * 刷新100个脏页到磁盘（可能）。
     * 合并至多5个插入缓冲（总是）。
     * 将日志缓冲刷新到磁盘（总是）。
     * 删除无用的Undo页（总是）。
     * 刷新100个或者10个脏页到磁盘（总是）。
     * 产生一个检查点（总是）。
   * innodb_io_capacity,默认值为200.表示磁盘IO的吞吐量。
     * 在合并插入缓冲时，合并插入缓冲的数量为innodb_io_capacity数值的5%
     * 在从缓冲区刷新脏页时，刷新脏页的数量为innodb_io_capacity。
     * innodb_max_dirty_pages_pct默认值为75.
     * innodb_adaptive_flushing（自适应刷新），该值影响每秒刷新脏页的数量。会通过判断重做日志的速度来判断最合适的刷新脏页的数量。
8. 关键特性
   * 插入缓冲：
     * 对于非聚集索引的插入或更新操作，是先判断插入的索引页是否在缓冲池中，如果在，则直接插入；如果不在，则先放入一个插入缓冲区中。
     * 必须满足以下两个条件：
       * 索引是辅助索引。
       * 索引不是唯一的。
   * 两次写：
     * 两次写由两部分组成：
       * 内存中的doublewrite buffer,大小为2MB
       * 物理磁盘上共享表空间中连续的128个页，大小同样为2MB
     * 当缓冲池的脏页刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先拷贝到内存中的doublewrite buffer,之后通过doublewrite buffer再分两次，每次写入1MB到共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。
   * 自适应哈希索引
     * InnoDB存储引擎会监控对表上索引的查找，如果观察到建立哈希索引会带来性能提升，则建立哈希索引，所以称为自适应的。
     * 自适应哈希索引通过缓冲池的B+树构造而来。
     * 哈希索引只能用来搜索等值的查询，不能用于非等值查询。
     * innodb_adaptive_hash_index来禁用或启用，默认为开启。

##### 第三章 文件

1. 参数文件：
   * mysql参数文件的确定：mysql —help|grep my.cnf
   * 参数类型：
     * 动态参数：运行中可更改
     * 静态参数：运行中不可更改
2. 日志文件：
   * 慢查询：
     * long_query_time，判断的是大于而非大于等于。
     * long_queries_not_using_indexes，如果运行的SQL语句没有使用索引，则会记录慢查询。
     * mysqldumpslow可以帮助分析慢查询文件，定位具体的查询语句
   * 查询日志：
     * 查询日志记录了所有对MySQL数据库请求的信息，不论这些请求是否得到了正确的执行。默认文件名为：主机名.log
   * 二进制日志：
     * 二进制日志记录了对数据库执行更改的所有操作，不包括查询操作。
     * 作用：
       * 恢复。
       * 复制。主备。
     * bin_log.index为二进制的索引文件，用来存储过往生产的二进制日志序号。
     * 开启二进制日志会对MySQL性能有影响，性能会降低1%。
3. InnoDB存储引擎文件：
   * InnoDB存储引擎，将存储的数据按表空间进行存放。默认配置下，会有一个初始化大小为10MB，名为ibdata1的文件。该文件通过参数innodb_data_file_path进行设置。
   * innodb_data_file_path=/db/ibdata1:2000M;/dr2/db/ibdata2:2000M:autoextend.这里讲两个文件组成表空间。如果两个文件位于不同的磁盘上，则可以对性能带来一定提升。
   * innodb_file_per_table，可以将每个基于InnoDB存储引擎的表单独产生一个表空间，文件名为表名.ibd.(这些单独的表空间仅存储该表的数据、索引和插入缓冲等信息，其余信息还是存在默认的表空间中)。
   * ib_logfile0和ib_logfile1。重做日志文件。记录了对于InnoDB存储引擎的事务日志。
     * 每个InnoDB存储引擎至少有1个重做日志文件组，每个文件组下至少有两个重做日志文件，如默认的ib_logfile1,ib_logfile1.
     * 参数innodb_log_file_size,innodb_log_files_in_group,innodb_mirrored_log_groups,innodb_log_group_home_dir影响着重做日志的属性。


##### 第4章 表

1. InnoDB存储引擎表类型
   * 在InnoDB存储引擎表中，每张表都有个主键，如果在创建表时没有显式的定义主键，则InnoDB存储引擎会按如下方式选择或创建主键。
     * 首先表中是否有非空的唯一索引，如果有，则该列即为主键。
     * 不符合上述条件，InnoDB存储引擎自动创建一个6个字节大小的指针。
2. InnoDB逻辑存储结构
   * 所有数据都被逻辑地存放在一个空间中，称之为表空间。表空间又由段，区，页组成。
   * 表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有的数据都是存放在表空间中。
   * InnoDB存储引擎是索引组织的，因此数据即索引，索引即数据。数据段即为B+树的叶节点，索引段即为B+树的非索引节点。
   * 区是由64个连续的页组成的，每个页大小为16KB，即每个区的大小为1MB。
     * 页是InnoDB磁盘管理的最小单位。常见的页类型有：
       * 数据页
       * Undo页
       * 系统页
       * 事务数据页
       * 插入缓冲位图页
       * 插入缓冲空闲列表页
       * 未压缩的二进制大对象页
       * 压缩的二进制大对象页
   * InnoDB数据的存放按行进行。每页存放的记录有规定，最多7992行。
3. InnoDB物理存储结构
   * InnoDB表由共享表空间、日志文件组、表结构定义文件组成。表结构定义文件以frm结尾，这个是与存储引擎无关的，任何存储引擎的表结构定义文件都一样，为.frm文件。
4. InnoDB行记录格式
   * InnoDB存储引擎提供了Compact和Redundant两种格式来存储记录数据，Redundant是为兼容之前的版本而保留的。
   * 可以通过show table status like 'table_name'来查看当前表使用的行格式。
   * Compact行记录格式：
     * Compact行记录格式：
       * 首部：是一个非NULL变长字段长度列表，而且是按照列的顺序逆序放置的。当列的长度小于255字节，用1字节表示，若大于，用2个字节表示。
       * 第二个部分是NULL标志位，该位表示了该行数据中是否有NULL值，用1表示。
       * 第三部分是记录头信息，固定占用5个字节。
       * 最后部分是实际存储的每个列的数据。NULL不占该部分任何数据，实际存储不占用任何数据。每行数据除了用户定义的列外，还有两个隐藏列，事务ID列和回滚指针列。若InnoDB表没有定义Primary Key，每行还会增加一个6字节的RowID列。
     * 固定长度char字段在未填充满其长度时，会用0x20来进行填充。
   * Redundant行记录格式：
     * 首部是一个字段长度偏移列表，同样是按照列的顺序逆序排放的。
     * 第二部分是记录头信息，固定占用6个字节。n_fields值代表一行中列的数量，占用10位。MySQL一行支持最多的列为1023.
     * 最后部分就是实际存储的每个列的数据。
     * 对于varchar的NULL值，Redundant行格式不占用任何存储空间，而char类型的NULL值需要占用空间。
   * 行溢出数据：
     * InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外，即作为行溢出数据。
     * Varchar中的N，是指字符的长度，Varchar类型最大支持65535指的是65535个字节。此外65535长度是指所有varchar列的长度总和，如果列的长度总和超出这个长度，依然无法创建。
     * InnoDB存储引擎的页为16KB，即16384个字节，一般多出的数据都是存储在B-tree Node的页类型中。当发生行溢出时，这个存放行溢出的页类型为Uncompress Blob page。
     * 数据页只保存数据的前768个字节。
   * char的行结构存储：
     * 在多字节字符集的情况下，char和varchar的行存储基本是没有区别的。
5. 约束
   * 数据完整性：
     * 实体完整性。可以通过定义主键或Unique Key约束保证实体的完整性。
     * 域完整性。
     * 参照完整性。可以通过定义外键以强制参照完整性。
     * InnoDB存储引擎提供了四种约束：
       * Primary Key
       * Unique Key
       * Foreign Key
       * Default
       * NOT NULL
   * 约束和索引的区别：
     * 约束是一个逻辑概念，用来保证数据的完整性，而索引是一个数据结构，有逻辑上的概念，在数据库中更是一个物理存储方式。
   * 外键：
     * InnoDB存储引擎在外键建立时会自动地对该列加一个索引。
     * 由于MySQL的外键是即时检查的，因此导入的每一行都会进行外键检查。但是可以忽视外键的检查。set foreign_key_checks=0.
6. 分区表
   * MySQL数据库支持的分区类型为水平分区，并不支持垂直分区。
   * 通过：show variable like '%partition%'来查看数据库是否启用了分区功能。
   * 数据库的应用分为两类：一类是OLTP(在线事务处理);另一类是OLAP(在线分析处理),如数据仓库。
   * 对OLAP应用，分区的确可以很好的提高查询性能。


##### 第五章 索引与算法

1. InnoDB存储引擎索引：
   * InnoDB存储引擎支持两种常见的索引，一种是B+树索引，另一种是哈希索引。
   * InnoDB存储引擎会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成哈希索引。
   * B+树索引并不能找到一个给定键值的具体行。能找到的只是被查找数据行所在的页。然后数据库通过把页读入内存，再在内存中进行查找，最后得到查找的数据。
2. B+树索引：
   * 数据库中的B+树索引可以分为聚集索引和辅助索引。
   * 聚集索引：
     * InnoDB存储引擎表是索引组织的，表中的数据是按照主键顺序存放。而聚集索引就是按照每张表的主键构造一颗B+树。并且叶节点中存放着整张表的行记录数据。
3. B+树索引的使用：
   * 当访问高选择性字段并从表中取出很少一部分行时，对这个字段添加B+树索引。但是如果出现了访问字段是高选择性的，但是取出的行数据占表中大部分数据时，这时MySQL数据库就不会使用B+树索引了。
4. 联合索引：
   * 联合索引可以对第二个键值进行排序。
5. 自适应哈希索引：
   * 可以在配置文件中启用innodb_adaptive_hash_index。
   * 自适应哈希索引对于等值查找非常快，但对于范围查找便无能为力了。

##### 第九章 性能调优

1. CPU的选择：
   * OLAP是CPU密集型的操作，而OLTP是IO密集型的操作。
   * 多个CPU或多核CPU对处理大并发量的请求有帮助。
2. 内存：
   * InnoDB存储引擎既缓存数据，又缓存索引，并将其缓存于一个很大的缓冲池中(InnoDB Buffer Pool)。
   * 应该在开发应用前预估“活跃”数据库的大小可能为多少。并以此确定数据库服务器内存的大小。
   * 可以通过比较物理磁盘的读取和内存读取的比例来判断缓冲池的命中率，通常InnoDB存储引擎的缓冲池的命中率不应该小于99%。
   * show global status like 'innodb%read%'
     * Innodb_buffer_pool_reads:表示从物理磁盘读取页的次数。
     * Innodb_buffer_pool_read_ahead:预读的次数
     * Innodb_buffer_pool_read_ahead_evicted:预读的页，但是没有被读取就从缓冲池中被替换的页的数量，一般用来判断预读的效率。
     * Innodb_buffer_pool_read_requests：从缓冲池中读取页的次数
     * Innodb_data_read:总共读入的字节数
     * Innodb_data_reads：发起读取请求的次数，每次读取可能需要读取多个页。
   * 缓冲池命中率：Innodb_buffer_pool_read_requests/(Innodb_buffer_pool_read_requests+Innodb_buffer_pool_read_ahead+Innodb_buffer_pool_reads)















