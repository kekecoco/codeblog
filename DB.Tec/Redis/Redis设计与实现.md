### Redis设计与实现(数据结构)

> 作者：黄健宏

#### 第一部分 数据结构与对象

##### 第二章 简单动态字符串
1. Redis构建了一种名为简单动态字符串(simple dynamic string,SDS)的抽象类型，并将SDS用作Redis的默认字符串表示。
2. Redis获取字符串的长度的时间复杂度为O(1)。
3. Redis的SDS可以避免产生内存缓冲区溢出。
4. Redis利用SDS的buf属性来保存二进制数据。
5. SDS的定义:  
    ```c
     struct sdsdr {
         // 记录buf数组中已使用的字节数量
         int len;
         // 记录buf数组中未使用的字节数量
         int free;
         // 字节数组,用户保存字符串
         char buf[];
     }
    ```  
6. 减少修改字符串时带来的内存重分配次数.SDS实现了空间预分配和惰性空间释放两种优化策略.
    + 空间预分配:
        + 如果对SDS进行修改后,SDS的长度将小于1MB,那么程序分配和len属性同样大小的未使用空间.这是SDS的len属性值和free属性值相同.
        + 如果对SDS修改后,SDS的属性值大于等于1MB,那么程序会分配1MB的未使用空间.
        + 通过这种预分配策略,SDS将连续增长N次字符串所需的内存重分配次数从必定的N次降低为最多N次.
    + 惰性空间释放:
        + 当SDS的API需要缩短SDS保存的字符串时,程序不立即使用内存重分配来回收缩短多出来的字节,而是使用free属性将这些字节的数量记录下来,并等待将来使用.
7. 二进制安全:
    + 所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据,程序不会对数组里的数据做任何的限制,过滤或者假设,数据在写入时是什么样,读出来时就是什么样.
    + Redis使用buf数组是来保存一系列二进制数据.

##### 第三章 链表
1. Redis的链表实现的特性：
   * 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1).
   * 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。
   * 带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1).
   * 带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O(1).
   * 多态：链表可以用来保存各种不同类型的值。
2. 链表和链表节点实现:
    ```c 
    typedef struct listNode{
        // 前置节点
        struct listNode *prev;
        // 后置节点
        struct listNode *next;
        void value;
    }listNode;   
    
    typedef struct list{
        // 表头节点
        listNode *head;
        // 表尾节点
        listNode *tail;
        // 链表所包含的节点数
        unsign long len;
        // 节点值复制函数
        void *(*dup)(void *ptr)
        // 节点值释放函数
        void (*free)(void *ptr)
        // 节点值对比函数
        int (*match)(void *ptr, void *key)
    }
    ```
    + dup函数用于复制链表节点所保存的值.
    + free函数用于释放链表节点所保存的值.
    + match函数则用于对比链表节点和另一个输入值是否相等.
    
##### 第四章 字典
1. Redis的数据库是使用字典来实现的。
2. Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。
3. Redis的哈希表使用链地址法来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来。
4. 哈希表的实现:
    ```c 
    typedef struct dicht{
        // 哈希表数组
        dictEntry **table;
        // 哈希表大小
        unsigned long size;
        // 哈希表大小掩码,用于计算索引值
        // 总是等于size-1
        unsigned long sizemask;
        // 该哈希表内已有节点的数量
        unsigned long used;
    } dictht;
    注: table属性是一个数组,数组中的每个元素都是指向dictEntry结构的指针,每个dictEntry都保存着一个键值对.
    size属性记录了哈希表的大小,也即是table数组的大小.
    used属性记录了哈希表目前已有节点(键值对)的数量.
    sizemask这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上.
    ```
5. 哈希表节点:
    ```c 
    typedef struct dictEntry{
        // 键
        void *key;
        // 值
        union {
            void *val;
            uint64_tu64;
            int64_ts64;
        } v;
        // 指向下个哈希表的节点,形成单链表
        struct dictEntry *next;
    }
    ```
6. 字典:
    ```C
    typedef struct dict{
        // 类型特定函数
        dictType *type;
        // 私有数据
        void *privdata;
        // 哈希表
        dictht ht[2];
        // rehash索引
        // 当rehash不进行时,值为-1
        int trehashidx;
    }dict;
    ```
7. 哈希算法:
    + 当要将一个新的键值对添加到字典里时,程序需要先根据键值对的键计算出哈希值和索引值,然后再根据索引值,将包含新键值对的哈希表节点放到指定的索引上面.

##### 第五章 跳跃表
1. 跳跃表支持平均O(logN),最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。
2. Redis使用跳跃表作为有序集合键的底层实现之一。
3. Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。
4. Redis跳跃表的实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息，而zskiplistNode则用于表示跳跃表节点。
5. 每个跳跃表的节点的层高都是1至32之间的随机数。

##### 第六章 整数集合
1. 整数集合是集合键的底层实现之一。
2. 整数集合是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16\_t,int32\_t或int64\_t的指数值，并且保证集合中不会出现重复元素。
3. 因为每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中已有的所有元素进行类型转换，所以向整数集合添加新元素的时间复杂度为O(N).

##### 第七章 压缩列表
1. 压缩列表是列表键和哈希键的底层实现之一。
2. 压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。

##### 第八章 对象
1. 每次当我们在Redis中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键，另一个对象用作键值对的值。
2. 对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种。
3. 字符串对象：
   * 字符串对象的编码可以是int,raw或者embstr.
4. 列表对象：
   * 列表对象的编码可以是ziplist或者linkedlist.
   * ziplist编码的列表对象使用压缩列表作为底层实现，linkedlist编码的列表对象使用双端链表作为底层实现。
   * 列表对象保存的所有字符串元素的长度都小于64字节；列表对象保存的元素数量小于512个；不能满足这两个条件的列表对象需要使用linkedlist编码。
5. 哈希对象：
   * 哈希对象的编码可以是ziplist或者hashtable
   * ziplist编码的哈希对象使用压缩列表作为底层实现：
     * 保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；
     * 先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。
   * hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：
     * 字典的每个键都是一个字符串对象，对象中保存了键值对的键；
     * 字典的每个值都是一个字符串对象，对象中保存了键值对的值。
   * 当哈希对象同时满足以下两个条件时，哈希对象使用ziplist编码：
     * 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；
     * 哈希对象保存的键值对数量小于512个。不能满足这两个条件的哈希对象需要使用hashtable编码。
6. 集合对象：
   * 集合对象的编码可以是intset或者hashtable。
   * intset编码的集合对象使用整数集合作为底层实现。
   * hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL。
   * 当集合对象同时满足以下两个条件时，对象使用intset编码：
     * 集合对象保存的所有元素都是整数值；
     * 集合对象保存的元素数量不超过512个。不满足这两个条件的集合对象需要使用hashtable。
7. 有序集合对象
   * 有序集合的编码可以是ziplist或者skiplist。
   * ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，而第二个元素则保存元素的分值。
   * 压缩列表内的集合元素按分值大小进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。
   * skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表。
   * 有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数。
   * 两种数据结构都会通过指针来共享相同元素的成员和分值，所以同时使用跳跃表和字典来保存集合元素不会产生任何重复的成员或者分值，也不会浪费额外的内存。
   * 当有序集合对象同时满足以下两个条件时，对象使用ziplist编码：
     * 有序结合保存的元素数量小于128个；
     * 有序集合保存的所有元素成员的长度都小于64字节。不能满足以上两个条件的有序集合对象使用skiplist编码。
8. 类型检查与命令多态
   * Redis中用于操作键的命令基本可以分为两类：
     * 一种可以对任何键执行，如del等
     * 另一种是只能对特定类型的键执行，如hSet等
   * 类型检查的实现：
     * 类型特定命令所进行的类型检查是通过redisObject结构的type属性实现的。
   * 多态命令的实现：
     * Redis还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。
   * 内存回收：
     * Redis在自己的对象系统中构建了一个引用计数实现内存回收。
   * 对象共享：
     * 对象的引用计数属性还带有引用计数的作用。
     * 在Redis中，让多个键共享同一个值对象需要执行下面两步：
       * 将数据库键的值指针指向一个现有的值对象
       * 将被共享的值对象的引用计数增一
       * Redis会在初始化服务器时，创建一万个字符串对象，这些对象包含了从0到9999的所有整数值，当服务器需要用到值为0到9999的字符串对象时，服务器就会使用这些共享对象，而不是新建
9. 对象的空转时长
   * redisObject结构中的lru属性，记录了对象最后一次被命令程序访问的时间。
   * OBJECT IDLETIME命令可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的。
   * 如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru,那么当服务器占用内存数超过了maxmemory选项所设置的上限时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。

#### 第十二章 事件
1. Redis服务器是一个事件驱动程序,服务器需要处理文件事件和时间事件.
2. 文件事件:
    * Redis基于Reactor模式开发了自己的网络时间处理器.这个处理器称为文件事件处理器.
    * 文件事件处理器使用I/O多路复用程序来同时监听多个套接字,并根据套接字目前执行的任务为套接字关联不同的事件处理器.
    * 当被监听的套接字准备好执行连接应答,读取,写入,关闭等操作时,与操作相对应的文件事件就会产生,这时文件处理器就会调用套接字之前关联好的事件处理器来处理这些事件.
    * 文件事件处理器由四个部分组成: 套接字, I/O多路复用程序, 文件事件分派器和事件处理器.
        * 尽管多个文件事件可能会并发的出现,但I/O多路复用程序总是会将所有产生的事件的套接字都放到一个队列里面,然后 通过这个队列,以有序,同步,每次一个套接字的方式
        向文件事件分派器传送套接字.当上一个套接字处理完毕后,I/O多路复用程序才会继续向文件事件分派器传送下一个套接字.
2. 时间事件:
    * 时间事件分为定时时间和周期性事件.
    * 服务器在一般情况下只执行serverCron函数一个时间事件,并且这个事件是周期性事件.
    * 文件事件和时间事件是合作关系,服务器会轮流处理这两种事件,并且处理事件的过程中也不会进行抢占.
    * 时间事件的实际处理时间通常会比设定的到达时间晚一些.
    
#### 第十三章 客户端
1. Redis服务器是典型的一对多服务器程序: 一个服务器可以与多个客户端建立网络连接.
2. Redis服务器使用单线程单进程的方式来处理命令请求,并与多个客户端进行网络通信.
3. 对于每个与服务器进行连接的客户端,服务器都为这些客户端建立了相应的redisClient结构,这个结构保存了客户端当前的状态信息,以及执行相关功能时需要用到的数据结构.
4. Redis服务器状态结构的clients属性是一个链表,这个链表保存了所有与服务器连接的客户端的状态结构,对客户端执行批量操作,或者查找某个指定的客户端,都可以通过遍历
clients链表来完成.
5. 客户端的套接字描述符,根据客户端类型的不同,fd属性值可以是-1或是大于-1的整数.
    * 伪客户端的fd属性的值为-1.
    * 普通客户端的fd属性值为大于-1的整数.
6. 客户端的authenticated属性用于记录客户端是否通过了身份验证,如果其值为0,表示客户端未通过身份验证;如果其值为1,那么表示客户端已经通过了身份验证.
7. 客户端的flags属性使用不同标志来表示客户端的角色,以及客户端当前所处的状态.
8. 输入缓冲区记录了客户端发送的命令请求,这个缓冲区大小不能超过1GB.
9. 命令的参数和参数个数会被记录在客户端状态的argv和argc属性里面,而cmd属性则记录了客户端要执行命令的实现函数.
10. 客户端有固定大小缓冲区和可变大小缓冲区两种.其中固定大小缓冲区的最大大小为16KB,而可变大小缓冲区的最大大小不能超过服务器设置的硬性限制值.

#### 第十四章 服务器
1. 一个命令请求从发送到完成主要包括以下步骤:
    * 客户端将命令发送给服务器.
    * 服务器读取命令请求,并分析出命令参数.
    * 命令执行器根据参数查找命令的实现函数,然后执行实现函数并得出命令回复.
    * 服务器将命令回复返回给客户端.
2. 命令执行器要做的第一件事就是根据客户端状态的argv[0]参数,在命令表中查找参数所指定的命令,并将找到的命令保存到客户端状态的cmd属性里面.
3. 命令表是一个字典,字典的键是命令的名字.,字典的值是一个个redisCommand结构,每个redisCommand结构记录了一个Redis命令的实现信息.
4. serverCron函数默认每隔100毫秒执行一次,它的工作主要包括更新服务器状态信息,处理服务器接收的SIGTERM信号,管理客户端资源和数据库状态,检查并执行持久化操作等等.
5. 服务器从启动到能处理客户端的命令请求需要执行以下步骤:
    * 初始化服务器状态.
    * 载入服务器配置.
    * 初始化服务器数据结构.
    * 还原数据库状态.
    * 执行事件循环.

#### 第十五章 复制



















