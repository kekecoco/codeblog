### Redis设计与实现(数据结构)

> 作者：黄健宏

#### 第一部分 数据结构与对象

##### 第二章 简单动态字符串

1. Redis构建了一种名为简单动态字符串(simple dynamic string,SDS)的抽象类型，并将SDS用作Redis的默认字符串表示。
2. Redis获取字符串的长度的时间复杂度为O(1)。
3. Redis的SDS可以避免产生内存缓冲区溢出。
4. Redis利用SDS的buf属性来保存二进制数据。

##### 第三章 链表

1. Redis的链表实现的特性：
   * 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1).
   * 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。
   * 带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1).
   * 带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O(1).
   * 多态：链表可以用来保存各种不同类型的值。

##### 第四章 字典

1. Redis的数据库是使用字典来实现的。
2. Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。
3. Redis的哈希表使用链地址法来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来。

##### 第五章 跳跃表

1. 跳跃表支持平均O(logN),最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。
2. Redis使用跳跃表作为有序集合键的底层实现之一。
3. Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。
4. Redis跳跃表的实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息，而zskiplistNode则用于表示跳跃表节点。
5. 每个跳跃表的节点的层高都是1至32之间的随机数。

##### 第六章 整数集合

1. 整数集合是集合键的底层实现之一。
2. 整数集合是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16\_t,int32\_t或int64\_t的指数值，并且保证集合中不会出现重复元素。
3. 因为每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中已有的所有元素进行类型转换，所以向整数集合添加新元素的时间复杂度为O(N).

##### 第七章 压缩列表

1. 压缩列表是列表键和哈希键的底层实现之一。
2. 压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。

##### 第八章 对象

1. 每次当我们在Redis中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键，另一个对象用作键值对的值。
2. 对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种。
3. 字符串对象：
   * 字符串对象的编码可以是int,raw或者embstr.
4. 列表对象：
   * 列表对象的编码可以是ziplist或者linkedlist.
   * ziplist编码的列表对象使用压缩列表作为底层实现，linkedlist编码的列表对象使用双端链表作为底层实现。
   * 列表对象保存的所有字符串元素的长度都小于64字节；列表对象保存的元素数量小于512个；不能满足这两个条件的列表对象需要使用linkedlist编码。
5. 哈希对象：
   * 哈希对象的编码可以是ziplist或者hashtable
   * ziplist编码的哈希对象使用压缩列表作为底层实现：
     * 保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；
     * 先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。
   * hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：
     * 字典的每个键都是一个字符串对象，对象中保存了键值对的键；
     * 字典的每个值都是一个字符串对象，对象中保存了键值对的值。
   * 当哈希对象同时满足以下两个条件时，哈希对象使用ziplist编码：
     * 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；
     * 哈希对象保存的键值对数量小于512个。不能满足这两个条件的哈希对象需要使用hashtable编码。
6. 集合对象：
   * 集合对象的编码可以是intset或者hashtable。
   * intset编码的集合对象使用整数集合作为底层实现。
   * hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL。
   * 当集合对象同时满足以下两个条件时，对象使用intset编码：
     * 集合对象保存的所有元素都是整数值；
     * 集合对象保存的元素数量不超过512个。不满足这两个条件的集合对象需要使用hashtable。
7. 有序集合对象
   * 有序集合的编码可以是ziplist或者skiplist。
   * ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，而第二个元素则保存元素的分值。
   * 压缩列表内的集合元素按分值大小进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。
   * skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表。
   * 有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数。
   * 两种数据结构都会通过指针来共享相同元素的成员和分值，所以同时使用跳跃表和字典来保存集合元素不会产生任何重复的成员或者分值，也不会浪费额外的内存。
   * 当有序集合对象同时满足以下两个条件时，对象使用ziplist编码：
     * 有序结合保存的元素数量小于128个；
     * 有序集合保存的所有元素成员的长度都小于64字节。不能满足以上两个条件的有序集合对象使用skiplist编码。
8. 类型检查与命令多态
   * Redis中用于操作键的命令基本可以分为两类：
     * 一种可以对任何键执行，如del等
     * 另一种是只能对特定类型的键执行，如hSet等
   * 类型检查的实现：
     * 类型特定命令所进行的类型检查是通过redisObject结构的type属性实现的。
   * 多态命令的实现：
     * Redis还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。
   * 内存回收：
     * Redis在自己的对象系统中构建了一个引用计数计数实现内存回收。
   * 对象共享：
     * 对象的引用计数属性还带有引用计数的作用。
     * 在Redis中，让多个键共享同一个值对象需要执行下面两步：
       * 将数据库键的值指针指向一个现有的值对象
       * 将被共享的值对象的引用计数增一
       * Redis会在初始化服务器时，创建一万个字符串对象，这些对象包含了从0到9999的所有整数值，当服务器需要用到值为0到9999的字符串对象时，服务器就会使用这些共享对象，而不是新建
9. 对象的空转时长
   * redisObject结构中的lru属性，记录了对象最后一次被命令程序访问的时间。
   * OBJECT IDLETIME命令可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的。
   * 如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru,那么当服务器占用内存数超过了maxmemory选项所设置的上限时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。





















