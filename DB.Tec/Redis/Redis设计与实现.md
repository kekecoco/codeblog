### Redis设计与实现(数据结构)

> 作者：黄健宏

#### 第一部分 数据结构与对象

##### 第二章 简单动态字符串
1. Redis构建了一种名为简单动态字符串(simple dynamic string,SDS)的抽象类型，并将SDS用作Redis的默认字符串表示。
2. Redis获取字符串的长度的时间复杂度为O(1)。
3. Redis的SDS可以避免产生内存缓冲区溢出。
4. Redis利用SDS的buf属性来保存二进制数据。
5. SDS的定义:  
    ```c
     struct sdsdr {
         // 记录buf数组中已使用的字节数量
         int len;
         // 记录buf数组中未使用的字节数量
         int free;
         // 字节数组,用户保存字符串
         char buf[];
     }
    ```  
6. 减少修改字符串时带来的内存重分配次数.SDS实现了空间预分配和惰性空间释放两种优化策略.
    + 空间预分配:
        + 如果对SDS进行修改后,SDS的长度将小于1MB,那么程序分配和len属性同样大小的未使用空间.这是SDS的len属性值和free属性值相同.
        + 如果对SDS修改后,SDS的属性值大于等于1MB,那么程序会分配1MB的未使用空间.
        + 通过这种预分配策略,SDS将连续增长N次字符串所需的内存重分配次数从必定的N次降低为最多N次.
    + 惰性空间释放:
        + 当SDS的API需要缩短SDS保存的字符串时,程序不立即使用内存重分配来回收缩短多出来的字节,而是使用free属性将这些字节的数量记录下来,并等待将来使用.
7. 二进制安全:
    + 所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据,程序不会对数组里的数据做任何的限制,过滤或者假设,数据在写入时是什么样,读出来时就是什么样.
    + Redis使用buf数组是来保存一系列二进制数据.

##### 第三章 链表
1. Redis的链表实现的特性：
   * 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1).
   * 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。
   * 带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1).
   * 带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O(1).
   * 多态：链表可以用来保存各种不同类型的值。
2. 链表和链表节点实现:
    ```c 
    typedef struct listNode{
        // 前置节点
        struct listNode *prev;
        // 后置节点
        struct listNode *next;
        void value;
    }listNode;   
    
    typedef struct list{
        // 表头节点
        listNode *head;
        // 表尾节点
        listNode *tail;
        // 链表所包含的节点数
        unsign long len;
        // 节点值复制函数
        void *(*dup)(void *ptr)
        // 节点值释放函数
        void (*free)(void *ptr)
        // 节点值对比函数
        int (*match)(void *ptr, void *key)
    }
    ```
    + dup函数用于复制链表节点所保存的值.
    + free函数用于释放链表节点所保存的值.
    + match函数则用于对比链表节点和另一个输入值是否相等.
    
##### 第四章 字典
1. Redis的数据库是使用字典来实现的。
2. Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。
3. Redis的哈希表使用链地址法来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来。
4. 哈希表的实现:
    ```c 
    typedef struct dicht{
        // 哈希表数组
        dictEntry **table;
        // 哈希表大小
        unsigned long size;
        // 哈希表大小掩码,用于计算索引值
        // 总是等于size-1
        unsigned long sizemask;
        // 该哈希表内已有节点的数量
        unsigned long used;
    } dictht;
    注: table属性是一个数组,数组中的每个元素都是指向dictEntry结构的指针,每个dictEntry都保存着一个键值对.
    size属性记录了哈希表的大小,也即是table数组的大小.
    used属性记录了哈希表目前已有节点(键值对)的数量.
    sizemask这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上.
    ```
5. 哈希表节点:
    ```c 
    typedef struct dictEntry{
        // 键
        void *key;
        // 值
        union {
            void *val;
            uint64_tu64;
            int64_ts64;
        } v;
        // 指向下个哈希表的节点,形成单链表
        struct dictEntry *next;
    }
    ```
6. 字典:
    ```C
    typedef struct dict{
        // 类型特定函数
        dictType *type;
        // 私有数据
        void *privdata;
        // 哈希表
        dictht ht[2];
        // rehash索引
        // 当rehash不进行时,值为-1
        int trehashidx;
    }dict;
    ```
7. 哈希算法:
    + 当要将一个新的键值对添加到字典里时,程序需要先根据键值对的键计算出哈希值和索引值,然后再根据索引值,将包含新键值对的哈希表节点放到指定的索引上面.

##### 第五章 跳跃表
1. 跳跃表支持平均O(logN),最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。
2. Redis使用跳跃表作为有序集合键的底层实现之一。
3. Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。
4. Redis跳跃表的实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息，而zskiplistNode则用于表示跳跃表节点。
5. 每个跳跃表的节点的层高都是1至32之间的随机数。

##### 第六章 整数集合
1. 整数集合是集合键的底层实现之一。
2. 整数集合是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16\_t,int32\_t或int64\_t的指数值，并且保证集合中不会出现重复元素。
3. 因为每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中已有的所有元素进行类型转换，所以向整数集合添加新元素的时间复杂度为O(N).

##### 第七章 压缩列表
1. 压缩列表是列表键和哈希键的底层实现之一。
2. 压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。

##### 第八章 对象
1. 每次当我们在Redis中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键，另一个对象用作键值对的值。
2. 对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种。
3. 字符串对象：
   * 字符串对象的编码可以是int,raw或者embstr.
4. 列表对象：
   * 列表对象的编码可以是ziplist或者linkedlist.
   * ziplist编码的列表对象使用压缩列表作为底层实现，linkedlist编码的列表对象使用双端链表作为底层实现。
   * 列表对象保存的所有字符串元素的长度都小于64字节；列表对象保存的元素数量小于512个；不能满足这两个条件的列表对象需要使用linkedlist编码。
5. 哈希对象：
   * 哈希对象的编码可以是ziplist或者hashtable
   * ziplist编码的哈希对象使用压缩列表作为底层实现：
     * 保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；
     * 先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。
   * hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：
     * 字典的每个键都是一个字符串对象，对象中保存了键值对的键；
     * 字典的每个值都是一个字符串对象，对象中保存了键值对的值。
   * 当哈希对象同时满足以下两个条件时，哈希对象使用ziplist编码：
     * 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；
     * 哈希对象保存的键值对数量小于512个。不能满足这两个条件的哈希对象需要使用hashtable编码。
6. 集合对象：
   * 集合对象的编码可以是intset或者hashtable。
   * intset编码的集合对象使用整数集合作为底层实现。
   * hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL。
   * 当集合对象同时满足以下两个条件时，对象使用intset编码：
     * 集合对象保存的所有元素都是整数值；
     * 集合对象保存的元素数量不超过512个。不满足这两个条件的集合对象需要使用hashtable。
7. 有序集合对象
   * 有序集合的编码可以是ziplist或者skiplist。
   * ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，而第二个元素则保存元素的分值。
   * 压缩列表内的集合元素按分值大小进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。
   * skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表。
   * 有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数。
   * 两种数据结构都会通过指针来共享相同元素的成员和分值，所以同时使用跳跃表和字典来保存集合元素不会产生任何重复的成员或者分值，也不会浪费额外的内存。
   * 当有序集合对象同时满足以下两个条件时，对象使用ziplist编码：
     * 有序结合保存的元素数量小于128个；
     * 有序集合保存的所有元素成员的长度都小于64字节。不能满足以上两个条件的有序集合对象使用skiplist编码。
8. 类型检查与命令多态
   * Redis中用于操作键的命令基本可以分为两类：
     * 一种可以对任何键执行，如del等
     * 另一种是只能对特定类型的键执行，如hSet等
   * 类型检查的实现：
     * 类型特定命令所进行的类型检查是通过redisObject结构的type属性实现的。
   * 多态命令的实现：
     * Redis还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。
   * 内存回收：
     * Redis在自己的对象系统中构建了一个引用计数实现内存回收。
   * 对象共享：
     * 对象的引用计数属性还带有引用计数的作用。
     * 在Redis中，让多个键共享同一个值对象需要执行下面两步：
       * 将数据库键的值指针指向一个现有的值对象
       * 将被共享的值对象的引用计数增一
       * Redis会在初始化服务器时，创建一万个字符串对象，这些对象包含了从0到9999的所有整数值，当服务器需要用到值为0到9999的字符串对象时，服务器就会使用这些共享对象，而不是新建
9. 对象的空转时长
   * redisObject结构中的lru属性，记录了对象最后一次被命令程序访问的时间。
   * OBJECT IDLETIME命令可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的。
   * 如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru,那么当服务器占用内存数超过了maxmemory选项所设置的上限时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。

#### 第十二章 事件
1. Redis服务器是一个事件驱动程序,服务器需要处理文件事件和时间事件.
2. 文件事件:
    * Redis基于Reactor模式开发了自己的网络时间处理器.这个处理器称为文件事件处理器.
    * 文件事件处理器使用I/O多路复用程序来同时监听多个套接字,并根据套接字目前执行的任务为套接字关联不同的事件处理器.
    * 当被监听的套接字准备好执行连接应答,读取,写入,关闭等操作时,与操作相对应的文件事件就会产生,这时文件处理器就会调用套接字之前关联好的事件处理器来处理这些事件.
    * 文件事件处理器由四个部分组成: 套接字, I/O多路复用程序, 文件事件分派器和事件处理器.
        * 尽管多个文件事件可能会并发的出现,但I/O多路复用程序总是会将所有产生的事件的套接字都放到一个队列里面,然后 通过这个队列,以有序,同步,每次一个套接字的方式
        向文件事件分派器传送套接字.当上一个套接字处理完毕后,I/O多路复用程序才会继续向文件事件分派器传送下一个套接字.
2. 时间事件:
    * 时间事件分为定时时间和周期性事件.
    * 服务器在一般情况下只执行serverCron函数一个时间事件,并且这个事件是周期性事件.
    * 文件事件和时间事件是合作关系,服务器会轮流处理这两种事件,并且处理事件的过程中也不会进行抢占.
    * 时间事件的实际处理时间通常会比设定的到达时间晚一些.
    
#### 第十三章 客户端
1. Redis服务器是典型的一对多服务器程序: 一个服务器可以与多个客户端建立网络连接.
2. Redis服务器使用单线程单进程的方式来处理命令请求,并与多个客户端进行网络通信.
3. 对于每个与服务器进行连接的客户端,服务器都为这些客户端建立了相应的redisClient结构,这个结构保存了客户端当前的状态信息,以及执行相关功能时需要用到的数据结构.
4. Redis服务器状态结构的clients属性是一个链表,这个链表保存了所有与服务器连接的客户端的状态结构,对客户端执行批量操作,或者查找某个指定的客户端,都可以通过遍历
clients链表来完成.
5. 客户端的套接字描述符,根据客户端类型的不同,fd属性值可以是-1或是大于-1的整数.
    * 伪客户端的fd属性的值为-1.
    * 普通客户端的fd属性值为大于-1的整数.
6. 客户端的authenticated属性用于记录客户端是否通过了身份验证,如果其值为0,表示客户端未通过身份验证;如果其值为1,那么表示客户端已经通过了身份验证.
7. 客户端的flags属性使用不同标志来表示客户端的角色,以及客户端当前所处的状态.
8. 输入缓冲区记录了客户端发送的命令请求,这个缓冲区大小不能超过1GB.
9. 命令的参数和参数个数会被记录在客户端状态的argv和argc属性里面,而cmd属性则记录了客户端要执行命令的实现函数.
10. 客户端有固定大小缓冲区和可变大小缓冲区两种.其中固定大小缓冲区的最大大小为16KB,而可变大小缓冲区的最大大小不能超过服务器设置的硬性限制值.

#### 第十四章 服务器
1. 一个命令请求从发送到完成主要包括以下步骤:
    * 客户端将命令发送给服务器.
    * 服务器读取命令请求,并分析出命令参数.
    * 命令执行器根据参数查找命令的实现函数,然后执行实现函数并得出命令回复.
    * 服务器将命令回复返回给客户端.
2. 命令执行器要做的第一件事就是根据客户端状态的argv[0]参数,在命令表中查找参数所指定的命令,并将找到的命令保存到客户端状态的cmd属性里面.
3. 命令表是一个字典,字典的键是命令的名字.,字典的值是一个个redisCommand结构,每个redisCommand结构记录了一个Redis命令的实现信息.
4. serverCron函数默认每隔100毫秒执行一次,它的工作主要包括更新服务器状态信息,处理服务器接收的SIGTERM信号,管理客户端资源和数据库状态,检查并执行持久化操作等等.
5. 服务器从启动到能处理客户端的命令请求需要执行以下步骤:
    * 初始化服务器状态.
    * 载入服务器配置.
    * 初始化服务器数据结构.
    * 还原数据库状态.
    * 执行事件循环.

#### 第十五章 复制
1. Redis的复制功能分为同步和命令传播两个操作:
    * 同步操作作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态.
    * 命令传播操作作用于在主服务器的数据库状态被修改,导致主从服务器的数据库状态不一致,让主从服务器的数据库状态重新回到一致.
2. 为了解决旧版复制功能在处理断线重复制时的低效问题,Redis从2.8版本开始,使用PSYNC命令替代SYNC命令来执行复制时的同步操作.
3. PSYNC命令具有完整重同步和部分重同步两种模式.
    * 完整重同步用于处理初次复制的情况.
    * 部分重同步用于处理断线后重复制的情况.
4. 部分重同步功能由以下三个部分构成:
    * 主服务器的复制偏移量和从服务器的复制偏移量.
    * 主服务器的复制积压缓冲区.
    * 服务器的运行ID(run ID).
5. 在命令传播阶段,从服务器默认会以每秒一次的频率,向主服务器发送命令: REPLCONF  ACK <replication_offset>

#### 第十六章 Sentinel
1. sentinel是redis高可用性的解决方案: 由一个或多个sentinel实例组成的sentinel系统可以监视任意多个主服务器以及下属的所有从服务器,
并在被监视的主服务器进入下线状态时,自动将下线服务器属下的某个从服务器升级为主服务器,然后由新的主服务器代替已下线的主服务器继续处理命令请求.
2. 对于每个被sentinel监视的主服务器来说,sentinel会创建两个连向主服务器的异步网络连接:
一个是命令连接,专门用于向主服务器发送命令,并接受命令回复.
另一个是订阅连接,专门用于订阅主服务器的__sentinel__:hello频道.
3. sentinel默认会以每十秒一次的频率,通过命令连接向被监视的主服务器发送INFO命令,并通过分析INFO命令的回复来获取主服务器的当前信息.
4. sentinel发现主服务器有新的从服务器出现时,sentinel除了会为这个新的从服务器创建响应的实例结构外,sentinel还会创建连接到从服务器的命令连接和订阅连接.
5. 选举领头sentinel:
    * 所有在线的sentinel都有被选举为领头sentinel的资格.
    * sentinel设置局部领头sentinel的规则是先到先得: 最先向目标sentinel发送设置要求的源sentinel将成为目标sentinel的局部领头sentinel,而
    之后收到的所有设置要求都会被目标sentinel拒绝.
6. Sentinel只是一个运行在特殊模式下的redis服务器,它使用了和普通模式不同的命令表.
7. Sentinel只会与主服务器和从服务器建立命令连接和订阅连接,Sentinel与Sentinel之间只创建命令连接.

#### 第十七章 集群
1. 节点通过握手来将其他节点添加到自己所处的集群当中.
2. 连接各个节点的工作可以使用CLUSTER MEET命令来完成,该命令的格式如下: CLUSTER MEET <ip> <port>
3. clusterNode结构保存了一个节点当前的状态,比如节点的创建时间,节点的名字,节点当前的配置纪元,节点的IP地址和端口等.
4. 每个节点都会使用一个clusterNode结构来记录自己的状态,并为集群中的所有其他节点(包括主从节点)都创建一个相应的clusterNode结构,依此来记录其他节点的状态.
5. 每个节点都保存着一个clusterState结构,这个结构记录了当前节点的视角下,集群目前所处的状态.
6. Redis集群通过分片的方式来保存数据库中的键值对:集群的整个数据库被分为16384个槽,数据库中的每个键都属于16384个槽中的一个,集群中的每个节点可以处理0个或最多16384个槽.
7. 通过向节点发送CLUSTER ADDSLOTS命令,我们可以将一个或多个槽指派给节点负责.
8. clusterNode结构的slots属性和numslot属性记录了节点负责处理哪些槽.
    * slots属性是一个二进制位数组,这个数组共包含16384个二进制位.
    * numslots属性记录节点负责处理槽的数量,也即是slots数组中值为1的二进制位的数量.
9. 节点会将自己的slots数组通过消息发送给集群中的其他节点,以此来告知其他节点自己目前负责处理哪些槽.
10. clusterState结构中的slots数组记录了集群中所有16384个槽的指派信息.
11. slots数组包含16384个项,每个数组项都是一个指向clusterNode结构的指针.
12. Redis的重新分片操作可以将任意数量的已经指派给某个节点的槽改为指派给另一个节点,并且将相关槽所属的键值对也会从源节点被移动到目标节点.
13. 重新分片操作可以在线进行,在重新分片的过程中,集群不需要下线,并且源节点和目标节点都可以继续处理命令请求.
14. Redis集群的重新分片操作是由Redis的集群管理软件redis-trib负责执行的,Redis提供了进行重新分片所需的所有命令,而redis-trib则通过向源节点和目标节点发送命令来进行
重新分片操作.
15. 如果节点A正在迁移槽i至节点B,那么当节点A没能在自己的数据库中找到命令指定的数据库键时,节点A会向客户端返回一个ASK错误,指引客户端到节点B继续查找指定的数据库键.
16. 集群里的从节点用于复制主节点,并在主节点下线时,代替主节点继续处理命令请求.

#### 第十八章 发布和订阅
1. 服务器状态在pubsub_channels字典保存了所有频道的订阅关系: SUBSCRIBE命令负责将客户端和被订阅频道关联到这个字典里面.而UNSUBSCRIBE命令则负责解除客户端和被退订频道之间的关系.
2. 服务器状态在pubsub_patterns链表保存了所有模式的订阅关系:PSUBSCRIBE命令负责将客户端和被订阅的模式记录到这个链表中,而PUNSUBSCRIBE命令则负责移除客户端和被退订模式在链表中的记录.
3. PUBLISH命令通过访问pubsub_channels字典来向频道的所有订阅者发送消息,通过访问pubsub_Pattern链表来向所有匹配频道的模式的订阅者发送消息.

#### 第十九章 事务
1. 事务提供了一种将多个命令打包,然后一次性,有序的执行的机制.
2. 多个命令会被入队到事务队列中,然后按先进先出的顺序执行.
3. 事务在执行的过程中不会被中断,当事务队列中的所有命令都被执行完毕后,事务才会结束.
4. 带有WATCH命令的事务会将客户端和被监视的键在数据库的watch_keys字典中进行关联,当键被修改时,程序会将所有监视被修改键的客户端REDIS_DIRTY_CAS打开.
5. 只有在客户端的REDIS_DIRTY_CAS标志未被打开时,服务器才会执行客户端提交的事务,否则的话,服务器将会拒绝执行客户端提交的事务.
6. Redis事务总是具有ACID中的原子性,一致性和隔离性,当服务运行在AOF持久化模式下,并且appendfsync选项的值为always时,事务也具有耐久性.

#### 第二十章 慢查询
1. Redis服务器将所有的慢查询日志保存在服务器状态的slowlog链表中,每个链表节点都包含一个slowlogEntry结构,每个slowlogEntry结构代表一条慢查询日志.
2. 打印和删除慢查询日志可以通过遍历slowlog链表来完成.
3. slowlog链表的长度就是服务器所保存慢查询日志的数量.
4. 新的慢查询日志会被添加到slowlog链表的表头,如果日志的数量超过slowlog-max-len选项的值,那么多出来的日志就会被删除.
